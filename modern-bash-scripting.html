<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.26">
<meta name="author" content="Ender KUŞ">
<title>Modern Bash Scripting</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock pre>code{display:block}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Modern Bash Scripting</h1>
<div class="details">
<span id="author" class="author">Ender KUŞ</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2025-12</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">İçindekiler</div>
<ul class="sectlevel1">
<li><a href="#_ön_bölümler">Ön Bölümler</a>
<ul class="sectlevel2">
<li><a href="#_yazar_hakkında">Yazar Hakkında</a></li>
<li><a href="#_önsöz_neden_bash_script">Önsöz: Neden Bash Script?</a></li>
<li><a href="#_bu_kitap_nasıl_kullanılmalı">Bu Kitap Nasıl Kullanılmalı?</a></li>
</ul>
</li>
<li><a href="#_temeller_ve_giriş">1. Temeller ve Giriş</a>
<ul class="sectlevel2">
<li><a href="#_bash_nedir_ve_neden_kullanılır">1.1. Bash Nedir ve Neden Kullanılır?</a></li>
<li><a href="#_terminal_temelleri">1.2. Terminal Temelleri</a></li>
<li><a href="#_i̇lk_script_merhaba_dünya">1.3. İlk Script: "Merhaba Dünya"</a></li>
<li><a href="#_shebang_nedir">1.4. Shebang (#!) Nedir?</a></li>
<li><a href="#_çalıştırma_i̇zinleri_ve_path_kavramı">1.5. Çalıştırma İzinleri ve PATH Kavramı</a></li>
<li><a href="#_yorum_satırları_ve_kod_düzeni">1.6. Yorum Satırları ve Kod Düzeni</a></li>
</ul>
</li>
<li><a href="#_değişkenler_ve_veri_tipleri">2. Değişkenler ve Veri Tipleri</a>
<ul class="sectlevel2">
<li><a href="#_değişken_tanımlama_ve_kullanma">2.1. Değişken Tanımlama ve Kullanma</a></li>
<li><a href="#_veri_tipleri_string_integer_vb">2.2. Veri Tipleri (String, Integer vb.)</a></li>
<li><a href="#_sabit_read_only_değişkenler">2.3. Sabit (Read-only) Değişkenler</a></li>
<li><a href="#_komut_çıktısını_değişkene_atama_command_substitution">2.4. Komut Çıktısını Değişkene Atama (Command Substitution)</a></li>
<li><a href="#_özel_bash_değişkenleri">2.5. Özel Bash Değişkenleri</a></li>
</ul>
</li>
<li><a href="#_kullanıcı_etkileşimi_ve_argümanlar">3. Kullanıcı Etkileşimi ve Argümanlar</a>
<ul class="sectlevel2">
<li><a href="#_scripte_argüman_gönderme">3.1. Script&#8217;e Argüman Gönderme</a></li>
<li><a href="#_kullanıcıdan_girdi_alma_read_komutu">3.2. Kullanıcıdan Girdi Alma (<code>read</code> komutu)</a></li>
<li><a href="#_argüman_kontrolü_ve_varsayılan_değerler">3.3. Argüman Kontrolü ve Varsayılan Değerler</a></li>
</ul>
</li>
<li><a href="#_diziler_arrays">4. Diziler (Arrays)</a>
<ul class="sectlevel2">
<li><a href="#_dizi_tanımlama">4.1. Dizi Tanımlama</a></li>
<li><a href="#_dizi_elemanlarına_erişim">4.2. Dizi Elemanlarına Erişim</a></li>
<li><a href="#_diziye_eleman_ekleme_ve_silme">4.3. Diziye Eleman Ekleme ve Silme</a></li>
<li><a href="#_dizi_üzerinde_i̇şlemler">4.4. Dizi Üzerinde İşlemler</a></li>
</ul>
</li>
<li><a href="#_aritmetik_i̇şlemler">5. Aritmetik İşlemler</a>
<ul class="sectlevel2">
<li><a href="#_let_expr_ve_kullanımı">5.1. <code>let</code>, <code>expr</code> ve <code>(( ))</code> Kullanımı</a></li>
<li><a href="#_temel_matematiksel_operatörler">5.2. Temel Matematiksel Operatörler</a></li>
<li><a href="#_kayan_noktalı_sayılarla_çalışmak_bc_kullanımı">5.3. Kayan Noktalı Sayılarla Çalışmak (bc kullanımı)</a></li>
</ul>
</li>
<li><a href="#_metin_string_i̇şlemleri">6. Metin (String) İşlemleri</a>
<ul class="sectlevel2">
<li><a href="#_string_birleştirme_concatenation">6.1. String Birleştirme (Concatenation)</a></li>
<li><a href="#_string_uzunluğunu_alma">6.2. String Uzunluğunu Alma</a></li>
<li><a href="#_alt_metin_substring_alma">6.3. Alt Metin (Substring) Alma</a></li>
<li><a href="#_metin_arama_ve_değiştirme">6.4. Metin Arama ve Değiştirme</a></li>
<li><a href="#_büyükküçük_harf_dönüşümleri">6.5. Büyük/Küçük Harf Dönüşümleri</a></li>
</ul>
</li>
<li><a href="#_karar_yapıları_decision_making">7. Karar Yapıları (Decision Making)</a>
<ul class="sectlevel2">
<li><a href="#_if_else_elif_yapıları">7.1. <code>if</code>, <code>else</code>, <code>elif</code> Yapıları</a></li>
<li><a href="#_test_operatörleri">7.2. Test Operatörleri</a></li>
<li><a href="#_mantıksal_operatörler_and_or_not">7.3. Mantıksal Operatörler (AND, OR, NOT)</a></li>
<li><a href="#_case_yapısı_ile_çoklu_seçim">7.4. <code>case</code> Yapısı ile Çoklu Seçim</a></li>
<li><a href="#_karmaşık_senaryolar_ve_pekiştirme_örnekleri">7.5. Karmaşık Senaryolar ve Pekiştirme Örnekleri</a></li>
</ul>
</li>
<li><a href="#_döngüler">8. Döngüler</a>
<ul class="sectlevel2">
<li><a href="#_for_döngüsü">8.1. <code>for</code> Döngüsü</a></li>
<li><a href="#_while_ve_until_döngüleri">8.2. <code>while</code> ve <code>until</code> Döngüleri</a></li>
<li><a href="#_döngü_kontrolü_break_ve_continue">8.3. Döngü Kontrolü: <code>break</code> ve <code>continue</code></a></li>
<li><a href="#_dosya_satırlarını_okuma_döngüsü">8.4. Dosya Satırlarını Okuma Döngüsü</a></li>
<li><a href="#_döngüler_i̇çin_pekiştirme_örnekleri">8.5. Döngüler İçin Pekiştirme Örnekleri</a></li>
</ul>
</li>
<li><a href="#_fonksiyonlar">9. Fonksiyonlar</a>
<ul class="sectlevel2">
<li><a href="#_fonksiyon_tanımlama_ve_çağırma">9.1. Fonksiyon Tanımlama ve Çağırma</a></li>
<li><a href="#_fonksiyonlara_parametre_gönderme">9.2. Fonksiyonlara Parametre Gönderme</a></li>
<li><a href="#_return_değeri_ve_exit_status">9.3. Return Değeri ve Exit Status</a></li>
<li><a href="#_değişken_kapsamı_local_vs_global">9.4. Değişken Kapsamı (Local vs Global)</a></li>
<li><a href="#_kütüphane_oluşturma_ve_source_kullanımı">9.5. Kütüphane Oluşturma ve <code>source</code> Kullanımı</a></li>
<li><a href="#_kapsamlı_fonksiyon_örnekleri">9.6. Kapsamlı Fonksiyon Örnekleri</a></li>
</ul>
</li>
<li><a href="#_girdiçıktı_yönlendirme_ve_dosya_i̇şlemleri">10. Girdi/Çıktı Yönlendirme ve Dosya İşlemleri</a>
<ul class="sectlevel2">
<li><a href="#_standart_akışlar_stdin_stdout_stderr">10.1. Standart Akışlar (Stdin, Stdout, Stderr)</a></li>
<li><a href="#_yönlendirme_operatörleri_2">10.2. Yönlendirme Operatörleri (<code>&gt;</code>, <code>&gt;&gt;</code>, <code>2&gt;</code>)</a></li>
<li><a href="#_pipe_kullanımı_ve_filtreleme">10.3. Pipe (<code>|</code>) Kullanımı ve Filtreleme</a></li>
<li><a href="#_dosya_varlığı_ve_i̇zin_kontrolleri_tekrar">10.4. Dosya Varlığı ve İzin Kontrolleri (Tekrar)</a></li>
</ul>
</li>
<li><a href="#_otomasyon_ve_i̇leri_konular">11. Otomasyon ve İleri Konular</a>
<ul class="sectlevel2">
<li><a href="#_cron_ile_zamanlanmış_görevler">11.1. Cron ile Zamanlanmış Görevler</a></li>
<li><a href="#_hata_ayıklama_debugging_teknikleri">11.2. Hata Ayıklama (Debugging) Teknikleri</a></li>
<li><a href="#_temel_regex_düzenli_i̇fadeler_kullanımı">11.3. Temel Regex (Düzenli İfadeler) Kullanımı</a></li>
<li><a href="#_awk_ve_sed_ile_metin_i̇şlemeye_giriş">11.4. <code>awk</code> ve <code>sed</code> ile Metin İşlemeye Giriş</a></li>
<li><a href="#_loglama_ve_hata_yönetimi">11.5. Loglama ve Hata Yönetimi</a></li>
</ul>
</li>
<li><a href="#_pratik_senaryolar_ve_projeler">12. Pratik Senaryolar ve Projeler</a>
<ul class="sectlevel2">
<li><a href="#_proje_1_sistem_bilgisi_raporlama_aracı">12.1. Proje 1: Sistem Bilgisi Raporlama Aracı</a></li>
<li><a href="#_proje_2_otomatik_dosyadizin_yedekleme_scripti">12.2. Proje 2: Otomatik Dosya/Dizin Yedekleme Scripti</a></li>
<li><a href="#_proje_3_log_dosyası_analiz_aracı">12.3. Proje 3: Log Dosyası Analiz Aracı</a></li>
<li><a href="#_proje_4_kullanıcı_yönetim_otomasyonu">12.4. Proje 4: Kullanıcı Yönetim Otomasyonu</a></li>
</ul>
</li>
<li><a href="#_ek_a_terminal_kısayolları">Appendix A: Ek A: Terminal Kısayolları</a>
<ul class="sectlevel2">
<li><a href="#_i̇mleç_hareketi">A.1. İmleç Hareketi</a></li>
<li><a href="#_düzenleme_ve_silme">A.2. Düzenleme ve Silme</a></li>
<li><a href="#_geçmiş_ve_arama">A.3. Geçmiş ve Arama</a></li>
<li><a href="#_süreç_kontrolü">A.4. Süreç Kontrolü</a></li>
</ul>
</li>
<li><a href="#_ek_b_genişletilmiş_linux_komutları_referansı">Appendix B: Ek B: Genişletilmiş Linux Komutları Referansı</a>
<ul class="sectlevel2">
<li><a href="#_1_dosya_ve_dizin_yönetimi">B.1. 1. Dosya ve Dizin Yönetimi</a></li>
<li><a href="#_2_dosya_arama_ve_bulma">B.2. 2. Dosya Arama ve Bulma</a></li>
<li><a href="#_3_arşivleme_ve_sıkıştırma">B.3. 3. Arşivleme ve Sıkıştırma</a></li>
<li><a href="#_4_sistem_i̇zleme_ve_performans">B.4. 4. Sistem İzleme ve Performans</a></li>
<li><a href="#_5_ağ_ve_bağlantı_networking">B.5. 5. Ağ ve Bağlantı (Networking)</a></li>
<li><a href="#_6_uzak_bağlantı_ve_transfer">B.6. 6. Uzak Bağlantı ve Transfer</a></li>
<li><a href="#_7_kullanıcı_ve_i̇zinler">B.7. 7. Kullanıcı ve İzinler</a></li>
<li><a href="#_8_süreç_process_yönetimi">B.8. 8. Süreç (Process) Yönetimi</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_ön_bölümler">Ön Bölümler</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_yazar_hakkında">Yazar Hakkında</h3>
<div class="paragraph">
<p>Merhaba, ben Ender KUŞ.</p>
</div>
<div class="paragraph">
<p>Yazılım geliştirme serüvenime Ruby on Rails ve PHP geliştiricisi olarak başladım. Hem yurt içinde hem de yurt dışında çeşitli firmalarda, farklı ölçeklerdeki projelerde yer aldım. Bu süreçte sadece uygulama kodu yazmakla kalmadım, o uygulamaların üzerinde koştuğu işletim sistemi katmanında da bolca ter döktüm.</p>
</div>
<div class="paragraph">
<p>Daha önce Kodlab yayınlarından çıkan <strong>Ruby Programlama</strong> kitabını sizlerle buluşturmuştum. Yazma ve paylaşma tutkum, beni bu sefer de Linux ve Bash dünyasının derinliklerine götürdü.</p>
</div>
<div class="paragraph">
<p>Şu anda Türkiye&#8217;nin önde gelen özel bir şirketinde Linux, İzleme (Monitoring) ve Otomasyon Takım Lideri olarak görev yapıyorum. Ekibimle birlikte karmaşık sistemleri yönetiyor, süreçleri otomatikleştiriyor ve altyapıların sağlıklı çalışmasını sağlıyoruz.</p>
</div>
<div class="paragraph">
<p>Bu kitapta, yıllar içinde edindiğim tecrübeleri ve "keşke yolun başındayken bilseydim" dediğim incelikleri samimi bir dille size aktarmaya çalıştım. Umarım bu satırlar, sizin terminal yolculuğunuzda da iyi bir rehber olur.</p>
</div>
</div>
<div class="sect2">
<h3 id="_önsöz_neden_bash_script">Önsöz: Neden Bash Script?</h3>
<div class="paragraph">
<p>Linux&#8217;ta aynı sıkıcı işleri tekrar tekrar yapmaktan, saatlerinizi heba etmekten yorulmadınız mı? O zaman bu kitap tam size göre!</p>
</div>
<div class="paragraph">
<p>Modern Bash Scripting, o sıkıcı görevleri otomatize etmeniz için ihtiyacınız olan tüm yetenekleri size kazandıracak. Bu kitabı okuduktan sonra Linux üzerinde çalışırken çok daha verimli olacaksınız. Ama daha da önemlisi; size söz veriyorum, geceleri artık daha fazla uyuyabileceksiniz! (Çünkü işleri script&#8217;ler yapacak.)</p>
</div>
<div class="paragraph">
<p>Kitabımız, temel düzeyde Linux bilgisine sahip olduğunuzu ve komut satırına aşina olduğunuzu varsayar. Ancak endişelenmeyin, giriş bölümlerinde hafızanızı tazeleyeceğiz.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bu_kitap_nasıl_kullanılmalı">Bu Kitap Nasıl Kullanılmalı?</h3>
<div class="paragraph">
<p>Bu kitaptan maksimum faydayı sağlamak istiyorsanız, kronolojik bir sıra izlemelisiniz. Çünkü her bölüm, sizi bir sonraki bölüme hazırlar. Bu yüzden maceraya birinci bölümden başlamanızı ve finiş çizgisine ulaşana kadar adım adım, bölüm bölüm ilerlemenizi tavsiye ederim.</p>
</div>
<div class="paragraph">
<p>Ayrıca, sadece okuyucu olmayın, uygulayıcı olun! Kitapta gördüğünüz her bir bash script&#8217;ini kendi ellerinizle yazmalı ve çalıştırmalısınız. Bir bash script&#8217;ini sadece okuyup geçmeyin; klavyenizin başına geçin ve o kodu çalıştırın!</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Yasal Uyarı ve Sorumluluk Reddi</div>
<div class="paragraph">
<p>Bu kitapta yer alan kodlar ve teknik bilgiler eğitim amaçlıdır. Komutları denerken oluşabilecek veri kayıplarından veya sistem hatalarından yazar sorumlu tutulamaz.</p>
</div>
<div class="paragraph">
<p>Scriptleri denerken lütfen test ortamları (Sanal Makine, Docker vb.) kullanın ve kritik sistemlerde çalıştırmadan önce mutlaka <strong>yedek alın</strong>. Tüm sorumluluk size aittir.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_temeller_ve_giriş">1. Temeller ve Giriş</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_bash_nedir_ve_neden_kullanılır">1.1. Bash Nedir ve Neden Kullanılır?</h3>
<div class="paragraph">
<p>Bash (Bourne Again SHell), Linux ve Unix dünyasının en popüler komut satırı kabuğudur (shell). İsmi, Unix&#8217;in ilk kabuklarından biri olan "Bourne Shell"in (sh) geliştiricisi Stephen Bourne&#8217;a bir saygı duruşu niteliğindedir ve kelime oyunu içerir ("Bourne Again" - "Born Again"). 1989 yılında Brian Fox tarafından GNU Projesi için yazılmıştır.</p>
</div>
<div class="paragraph">
<p>Peki, "kabuk" (shell) derken neyi kastediyoruz?
Kabuk, sizinle (kullanıcı) işletim sisteminin çekirdeği (kernel) arasında bir köprü görevi gören, metin tabanlı bir arayüzdür. Siz klavyeden komutlar girersiniz, kabuk bu komutları yorumlar ve çekirdeğe iletir. Çekirdek işlemi yapar, sonucu kabuğa gönderir, kabuk da size gösterir.</p>
</div>
<div class="paragraph">
<p><strong>Neden Bash Kullanmalıyız?</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Her Yerdedir:</strong> Hemen hemen her Linux dağıtımında, macOS&#8217;ta ve artık Windows (WSL) üzerinde varsayılan veya kolayca erişilebilir durumdadır. Bir sunucuya bağlandığınızda sizi karşılayacak olan şey muhtemelen Bash&#8217;tir.</p>
</li>
<li>
<p><strong>Otomasyonun Kalbidir:</strong> Sistem yöneticileri ve geliştiriciler için hayat kurtarıcıdır. Her gün elle yaptığınız o sıkıcı dosya yedekleme işlemini, log analizini veya sunucu güncellemesini tek bir Bash script&#8217;i ile otomatik hale getirebilirsiniz.</p>
</li>
<li>
<p><strong>Yapıştırıcıdır:</strong> Bash, farklı programları birbirine bağlama konusunda ustadır. <code>grep</code>, <code>awk</code>, <code>sed</code> gibi güçlü araçları Bash ile birleştirerek harikalar yaratabilirsiniz.</p>
</li>
<li>
<p><strong>Hız ve Verimlilik:</strong> Grafik arayüzler (GUI) bazen yavaştır veya her işi yapamaz. Komut satırı ise ışık hızındadır ve size sistem üzerinde tam kontrol sağlar.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Kısacası Bash öğrenmek, bilgisayarınızla konuşmanın en doğrudan ve en güçlü yolunu öğrenmektir.</p>
</div>
</div>
<div class="sect2">
<h3 id="_terminal_temelleri">1.2. Terminal Temelleri</h3>
<div class="paragraph">
<p>Bash script yazmaya başlamadan önce, komut satırında kendimizi evimizde gibi hissetmeliyiz. "Ben zaten bunları biliyorum" diyorsanız harika, hızlıca bir hafıza tazelemesi yapıp geçebiliriz.</p>
</div>
<div class="paragraph">
<p>Terminali açtığınızda sizi genellikle şöyle bir satır karşılar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">kullanici@bilgisayar:~$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buradaki <code>$</code> işareti (bazen <code>#</code> olabilir, eğer root iseniz), Bash&#8217;in sizden komut beklediğini gösterir. <code>~</code> (tilde) işareti ise o an ev dizininizde (home directory) olduğunuzu belirtir.</p>
</div>
<div class="paragraph">
<p>İşte script yazarken sıkça kullanacağımız, adınız gibi bilmeniz gereken o temel komutlar:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><code>pwd</code> (Print Working Directory):</strong> "Neredeyim?" sorusunun cevabıdır. O an dosya sisteminin hangi klasöründe olduğunuzu tam yol (path) olarak gösterir.</p>
</li>
<li>
<p><strong><code>ls</code> (List):</strong> Bulunduğunuz klasördeki dosya ve klasörleri listeler.</p>
</li>
<li>
<p><code>ls -l</code>: Detaylı listeleme (izinler, boyut, tarih vb.).</p>
</li>
<li>
<p><code>ls -a</code>: Gizli dosyaları (baştan nokta ile başlayanlar) da gösterir.</p>
</li>
<li>
<p><strong><code>cd</code> (Change Directory):</strong> Klasörler arası ışınlanma aracınızdır.</p>
</li>
<li>
<p><code>cd Documents</code>: Belgeler klasörüne girer.</p>
</li>
<li>
<p><code>cd ..</code>: Bir üst klasöre çıkar.</p>
</li>
<li>
<p><code>cd ~</code> (veya sadece <code>cd</code>): Doğrudan ev dizininize döner.</p>
</li>
<li>
<p><code>cd -</code>: Bir önceki bulunduğunuz klasöre geri döner (TV kumandasındaki "Last Channel" tuşu gibi).</p>
</li>
<li>
<p><strong><code>mkdir</code> (Make Directory):</strong> Yeni bir klasör oluşturur.</p>
</li>
<li>
<p><code>mkdir projelerim</code></p>
</li>
<li>
<p><strong><code>touch</code>:</strong> Boş bir dosya oluşturur veya var olan dosyanın zaman damgasını günceller.</p>
</li>
<li>
<p><code>touch notlar.txt</code></p>
</li>
<li>
<p><strong><code>rm</code> (Remove):</strong> <strong>Dikkat!</strong> Dosya veya klasör siler. Geri dönüşüm kutusu yoktur, giden gider.</p>
</li>
<li>
<p><code>rm dosya.txt</code>: Dosyayı siler.</p>
</li>
<li>
<p><code>rm -rf klasör</code>: Klasörü ve içindeki her şeyi zorla siler (Çok dikkatli olun!).</p>
</li>
<li>
<p><strong><code>man</code> (Manual):</strong> Her şeyin kullanım kılavuzu. <code>man ls</code> yazarak <code>ls</code> komutunun tüm detaylarını öğrenebilirsiniz.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Bu komutlar, Bash ile dans ederken atacağınız en temel adımlardır.</p>
</div>
</div>
<div class="sect2">
<h3 id="_i̇lk_script_merhaba_dünya">1.3. İlk Script: "Merhaba Dünya"</h3>
<div class="paragraph">
<p>Yazılım dünyasının değişmez geleneğiyle başlayalım: Ekrana "Merhaba Dünya" yazdırmak. Ancak bunu yaparken, Linux dünyasının efsanevi (ve bazen korkutucu bulunan) editörü <strong>vi</strong>'yi kullanacağız. Korkmayın, sadece hayatta kalmanıza yetecek kadarını anlatacağım.</p>
</div>
<div class="paragraph">
<p>Bir script dosyası oluşturmak için <code>vi</code> editörünü şöyle çağırıyoruz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">vi merhaba.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu komutu yazdığınızda karşınıza boş bir ekran gelecek. Şu an <strong>Komut Modu</strong>'ndasınız (Command Mode). Yani klavyeye bastığınızda harf yazmaz, komut verirsiniz. Yazı yazmak için <strong>Ekleme Modu</strong>'na (Insert Mode) geçmeliyiz.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Klavyeden <strong><code>i</code></strong> tuşuna basın. (Ekranın sol alt köşesinde <code>-- INSERT --</code> yazısını görebilirsiniz).</p>
</li>
<li>
<p>Artık yazabiliriz. Şu satırı yazın:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo "Merhaba Dünya"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu işimizi görecektir. Şimdi dosyayı kaydedip çıkmamız lazım.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Önce <strong><code>ESC</code></strong> tuşuna basarak Ekleme Modu&#8217;ndan çıkın (<code>-- INSERT --</code> yazısı kaybolmalı).</p>
</li>
<li>
<p>Ardından sırasıyla <strong><code>:</code></strong> (iki nokta üst üste), <strong><code>w</code></strong> (write - kaydet) ve <strong><code>q</code></strong> (quit - çık) tuşlarına basın. Ekranın sol alt köşesinde <code>:wq</code> göreceksiniz.</p>
</li>
<li>
<p><strong><code>Enter</code></strong> tuşuna basın.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Tebrikler! İlk dosyanızı <code>vi</code> ile oluşturdunuz. Şimdi bu şaheseri çalıştıralım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">bash merhaba.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer her şey yolunda gittiyse, terminalde şunu görmelisiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Merhaba Dünya</pre>
</div>
</div>
<div class="paragraph">
<p>Hoş geldiniz! Artık resmen Bash script dünyasına adım attınız.</p>
</div>
</div>
<div class="sect2">
<h3 id="_shebang_nedir">1.4. Shebang (#!) Nedir?</h3>
<div class="paragraph">
<p>Bir önceki örnekte dosyanın içine sadece <code>echo "Merhaba Dünya"</code> yazdık ve onu <code>bash merhaba.sh</code> diyerek çalıştırdık. Yani Linux&#8217;a "Bu dosyayı al ve Bash yorumlayıcısı ile çalıştır" emrini verdik.</p>
</div>
<div class="paragraph">
<p>Ancak profesyonel dünyada script&#8217;ler genellikle doğrudan isimleriyle (örneğin <code>./merhaba.sh</code>) çalıştırılır. Linux&#8217;un bu dosyanın bir Bash script&#8217;i olduğunu anlayabilmesi için dosyanın <strong>en başına</strong> özel bir satır eklemeliyiz. İşte buna <strong>Shebang</strong> diyoruz.</p>
</div>
<div class="paragraph">
<p>Shebang, <code>#</code> (sharp) ve <code>!</code> (bang) karakterlerinin birleşiminden oluşur ve ardından yorumlayıcının yolu gelir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu satır, işletim sistemine şunu söyler: "Hey, bu dosyanın geri kalanını <code>/bin/bash</code> programını kullanarak çalıştır!"</p>
</div>
<div class="paragraph">
<p>Eğer Python script&#8217;i yazsaydık <code><mark>!/usr/bin/python3</code>, Perl yazsaydık <code></mark>!/usr/bin/perl</code> kullanacaktık.</p>
</div>
<div class="paragraph">
<p>Hadi script&#8217;imizi güncelleyelim. <code>vi merhaba.sh</code> ile dosyayı açın ve en başa şu satırı ekleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash
echo "Merhaba Dünya"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık script&#8217;imiz kimliğini kazandı. Ancak henüz "kendi başına" çalışmaya hazır değil. Neden mi? Cevabı bir sonraki başlıkta.</p>
</div>
</div>
<div class="sect2">
<h3 id="_çalıştırma_i̇zinleri_ve_path_kavramı">1.5. Çalıştırma İzinleri ve PATH Kavramı</h3>
<div class="paragraph">
<p>Shebang satırını ekledikten sonra script&#8217;i şu şekilde çalıştırmayı deneyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">./merhaba.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Muhtemelen şu hatayı alacaksınız: <code>Permission denied</code> (Erişim engellendi).
Linux&#8217;ta güvenlik gereği, oluşturduğunuz dosyalar varsayılan olarak "çalıştırılabilir" (executable) değildir. Bir dosyanın program gibi çalışabilmesi için ona <strong>çalıştırma izni (+x)</strong> vermelisiniz.</p>
</div>
<div class="paragraph">
<p>Bunu <code>chmod</code> (change mode) komutuyla yapıyoruz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">chmod +x merhaba.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi tekrar deneyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">./merhaba.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ve bingo! "Merhaba Dünya" yazısını gördünüz.</p>
</div>
<div class="paragraph">
<p><strong>Peki neden <code>./</code> koyuyoruz?</strong>
Normalde <code>ls</code>, <code>git</code>, <code>vi</code> gibi komutları yazarken başlarına <code>./</code> koymayız. Çünkü bu komutların bulunduğu klasörler (genellikle <code>/bin</code>, <code>/usr/bin</code> vb.), sistemin <strong>PATH</strong> adı verilen özel bir değişkeninde kayıtlıdır. Linux, bir komut yazdığınızda onu PATH içindeki klasörlerde arar.</p>
</div>
<div class="paragraph">
<p>Sizin oluşturduğunuz script şu anki klasörde duruyor ve Linux güvenlik sebebiyle (yanlışlıkla aynı isimli bir dosyayı çalıştırmamanız için) <strong>mevcut klasörü (current directory) PATH içinde saymaz.</strong></p>
</div>
<div class="paragraph">
<p>Bu yüzden Linux&#8217;a "Gitme, uzağa bakma; script tam olarak burada, bu klasörün (<code>.</code>) içinde!" demek için dosya yolunu açıkça belirtiriz: <code>./merhaba.sh</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_yorum_satırları_ve_kod_düzeni">1.6. Yorum Satırları ve Kod Düzeni</h3>
<div class="paragraph">
<p>Kod yazmak sadece bilgisayarlar için değil, insanlar (ve gelecekteki siz) içindir. 6 ay sonra kendi script&#8217;inizi açtığınızda "Ben burada ne yapmaya çalışmışım?" diye boş gözlerle bakmak istemiyorsanız, <strong>yorum satırlarını</strong> kullanın.</p>
</div>
<div class="paragraph">
<p>Bash&#8217;te <code>#</code> karakterinden sonra gelen her şey yorum olarak kabul edilir ve çalıştırılırken görmezden gelinir (Shebang hariç, o özeldir çünkü ilk satırdadır).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

# Bu script ekrana selamlama mesajı yazar.
# Yazan: Ender Kuş
# Tarih: 2025-12

echo "Merhaba Dünya" # Burası ekrana çıktı verir</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Kod Düzeni İpuçları:</strong>
1.  <strong>Başlık Ekleyin:</strong> Script&#8217;in ne işe yaradığını, kimin yazdığını en başa not düşün.
2.  <strong>Girinti (Indentation) Kullanın:</strong> İleride <code>if</code> veya <code>while</code> blokları yazarken, kodun okunabilir olması için içerideki satırları boşluk veya tab ile içeriden başlatın. Okunabilirlik, hatasız kodun anahtarıdır.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_değişkenler_ve_veri_tipleri">2. Değişkenler ve Veri Tipleri</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_değişken_tanımlama_ve_kullanma">2.1. Değişken Tanımlama ve Kullanma</h3>
<div class="paragraph">
<p>Programlamanın ve script yazmanın en temel yapı taşı değişkenlerdir. Değişkenleri, verileri (bir isim, bir dosya yolu, bir sayı) geçici olarak hafızada tuttuğumuz kutucuklar gibi düşünebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Bash&#8217;te değişken tanımlamak oldukça basittir, ancak çok katı bir kural vardır: <strong>Eşittir işaretinin sağında ve solunda boşluk olmamalıdır!</strong></p>
</div>
<div class="paragraph">
<p><strong>Yanlış:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">isim = "Ender"   # HATA! Boşluk olmayacak.
yas = 30         # HATA!</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Doğru:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">isim="Ender"
yas=30</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Değişken İsimlendirme Kuralları</strong>
Bash, değişken isimleri konusunda bazı kurallara sahiptir. Hata almamak için bunlara uymalısınız:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Harf, Sayı ve Alt Çizgi:</strong> Değişken isimleri sadece harf (<code>a-z</code>, <code>A-Z</code>), sayı (<code>0-9</code>) ve alt çizgi (<code>_</code>) içerebilir.</p>
</li>
<li>
<p><strong>Sayı ile Başlayamaz:</strong> bir değişken ismi sayı ile başlayamaz. <code>1inci_ders</code> hatalıdır, <code>ders_1</code> geçerlidir.</p>
</li>
<li>
<p><strong>Büyük/Küçük Harf Duyarlıdır:</strong> <code>ISIM</code>, <code>isim</code> ve <code>Isim</code> üç farklı değişkendir.</p>
</li>
<li>
<p><strong>Özel Karakter Yok:</strong> <code>!</code>, <code>*</code>, <code>-</code>, <code>?</code> gibi karakterler isimlendirmede kullanılamaz. (Örn: <code>benim-adım</code> yanlıştır, <code>benim_adim</code> doğrudur).</p>
</li>
<li>
<p><strong>Gelenek:</strong> Genellikle sistem değişkenleri (PATH, HOME) BÜYÜK HARFLE, kendi tanımladığımız değişkenler küçük_harf veya kucukHarf (camelCase) ile yazılır.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Değişkeni Kullanmak</strong>
Tanımladığımız değişkenin içindeki değeri okumak için başına <code>$</code> (dolar) işareti koyarız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo $isim
echo $yas</code></pre>
</div>
</div>
<div class="paragraph">
<p>Daha güvenli ve temiz bir kullanım için değişken ismini süslü parantez içine almak (<code>${isim}</code>) iyi bir alışkanlıktır. Bu, değişkenin nerede bittiğini Bash&#8217;e açıkça gösterir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo "Benim adım ${isim} ve yaşım ${yas}."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu yaptığımız işleme programlama literatüründe <strong>String Interpolation</strong> (Metin İçine Değişken Gömme) denir. Çift tırnak kullandığımız sürece, Bash içerideki değişkenleri (${&#8230;&#8203;}) algılar ve yerlerine gerçek değerlerini yazar.</p>
</div>
<div class="paragraph">
<p>Eğer süslü parantez kullanmazsak ne olur?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">kelime="Bash"
echo "$kelimeing"
# Bash burada 'kelimeing' adında bir değişken arar, bulamaz ve boş basar.
# Doğrusu: echo "${kelime}ing" -&gt; Bashing</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Değişkeni Silmek (Unset)</strong>
Tanımladığınız bir değişkenle işiniz bittiğinde veya onu hafızadan tamamen silmek istediğinizde <code>unset</code> komutunu kullanabilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">isim="Mehmet"
echo $isim  # Çıktı: Mehmet

unset isim
echo $isim  # Çıktı: (Boş bir satır, çünkü değişken artık yok)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_veri_tipleri_string_integer_vb">2.2. Veri Tipleri (String, Integer vb.)</h3>
<div class="paragraph">
<p>Bash, C veya Java gibi "strongly typed" (sıkı tipli) bir dil değildir. Bash&#8217;te değişkenlerin "tipi" (türü) o kadar belirgin değildir; aslında Bash için hemen hemen her şey bir <strong>String</strong>'dir (metin).</p>
</div>
<div class="paragraph">
<p><strong>String (Metin)</strong>
En sık kullanacağınız veri tipidir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">mesaj="Merhaba Dünya"
dosya_yolu="/home/ender/belgeler"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Integer (Tamsayı)</strong>
Bash, değişkenlere sayı atadığınızda onları saklar, ancak matematiksel işlem yapmadığınız sürece onları da metin gibi görür.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sayi=100
echo $sayi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Tırnak İşaretlerinin Sırrı (Quotes)</strong>
Bash&#8217;te "Çift Tırnak" (<code>"</code>) ve 'Tek Tırnak' (<code>'</code>) arasında hayati bir fark vardır:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Çift Tırnak (<code>"</code>):</strong> İçindeki değişkenleri yorumlar.</p>
</li>
<li>
<p><strong>Tek Tırnak (<code>'</code>):</strong> İçindekine dokunmaz, ne görüyorsa onu basar (Literal string).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Örnekle görelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">isim="Ali"

echo "Merhaba $isim"  # Çıktı: Merhaba Ali
echo 'Merhaba $isim'  # Çıktı: Merhaba $isim</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer değişkenlerin değerini görmek istiyorsanız çift tırnak, içinde <code>$</code>, <code>!</code> gibi özel karakterler geçen bir metni (örneğin bir şifre) olduğu gibi korumak istiyorsanız tek tırnak kullanın.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sabit_read_only_değişkenler">2.3. Sabit (Read-only) Değişkenler</h3>
<div class="paragraph">
<p>Bazen bir script içinde tanımladığınız bir değerin, programın ilerleyen kısımlarında kazara değiştirilmesini istemezsiniz. Örneğin, script&#8217;in çalıştığı ana dizin veya bir API anahtarı gibi.</p>
</div>
<div class="paragraph">
<p>Bash&#8217;te bir değişkeni "sabit" (değiştirilemez) yapmak için <code>readonly</code> komutu kullanılır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

readonly SIRKET_ADI="TechCorp"
TR="Türkiye"
readonly TR

echo "Şirket: $SIRKET_ADI"
echo "Ülke: $TR"

# Değiştirmeye çalışalım
SIRKET_ADI="NewCorp"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer bu script&#8217;i çalıştırırsanız, son satırda şöyle bir hata alırsınız:
<code>bash: SIRKET_ADI: readonly variable</code></p>
</div>
<div class="paragraph">
<p>Bu, scriptinizin güvenliği ve tutarlılığı için harika bir önlemdir.</p>
</div>
</div>
<div class="sect2">
<h3 id="_komut_çıktısını_değişkene_atama_command_substitution">2.4. Komut Çıktısını Değişkene Atama (Command Substitution)</h3>
<div class="paragraph">
<p>Bash&#8217;in en güçlü özelliklerinden biri budur! Bir Linux komutunun çıktısını (output) alıp bir değişkene atayabilir ve bunu script&#8217;inizde kullanabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Bunun için iki yöntem vardır, ancak modern dünyada <strong>birincisini</strong> kullanmanızı şiddetle tavsiye ederim.</p>
</div>
<div class="paragraph">
<p><strong>Yöntem 1: <code>$()</code> Kullanımı (Önerilen)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">tarih=$(date +%F)
dosya_sayisi=$(ls | wc -l)
neredeyim=$(pwd)

echo "Bugün tarih: $tarih"
echo "Burada $dosya_sayisi adet dosya var."
echo "Şu an $neredeyim klasöründeyiz."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bash, önce <code>$()</code> parantezinin içindeki komutu çalıştırır, çıkan sonucu alır ve değişkene yapıştırır.</p>
</div>
<div class="paragraph">
<p><strong>Yöntem 2: Backticks <code> ` ` </code> Kullanımı (Eski)</strong>
Klavyede genellikle noktalı virgülün orada veya <code>AltGr</code> ile yapılan, tırnak işaretine benzeyen ama yatık olan işarettir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">tarih=`date`</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu yöntem hala çalışır ancak okunması zordur ve iç içe komut kullanırken (nested commands) başınızı ağrıtır. O yüzden <code>$()</code> ile yola devam edin.</p>
</div>
</div>
<div class="sect2">
<h3 id="_özel_bash_değişkenleri">2.5. Özel Bash Değişkenleri</h3>
<div class="paragraph">
<p>Bash, siz daha script&#8217;inizi yazmaya başlamadan önce sizin için arka planda birçok değişkeni hazır eder. Bunlara <strong>Ortam Değişkenleri (Environment Variables)</strong> denir.</p>
</div>
<div class="paragraph">
<p>İşte en sık karşılaşacaklarınız:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>$HOME</code>: O anki kullanıcının ev dizini (Örn: <code>/home/ender</code>).</p>
</li>
<li>
<p><code>$USER</code>: O anki kullanıcının adı.</p>
</li>
<li>
<p><code>$PWD</code>: Bulunulan dizin (pwd komutunun değişken hali).</p>
</li>
<li>
<p><code>$SHELL</code>: Hangi kabuğu kullandığınız.</p>
</li>
<li>
<p><code>$HOSTNAME</code>: Bilgisayarın ağ üzerindeki adı.</p>
</li>
<li>
<p><code>$UID</code>: Kullanıcı ID numarası (User ID). Özellikle script&#8217;in root (UID 0) olarak çalışıp çalışmadığını kontrol etmek için kullanılır.</p>
</li>
<li>
<p><code>$RANDOM</code>: 0 ile 32767 arasında rastgele bir sayı üretir.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Örnek:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

echo "Merhaba $USER, hoş geldin!"
echo "Ev dizinin: $HOME"
echo "Senin kullanici numaran: $UID"
echo "Rastgele bir sayı: $RANDOM"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu değişkenler, script&#8217;inizi kimin, nerede çalıştırdığına göre dinamik davranmasını sağlar. İlerleyen bölümlerde (özellikle karar yapıları ve döngülerde) bu değişkenleri kullanarak çok daha yetenekli script&#8217;ler yazacağız.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_kullanıcı_etkileşimi_ve_argümanlar">3. Kullanıcı Etkileşimi ve Argümanlar</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_scripte_argüman_gönderme">3.1. Script&#8217;e Argüman Gönderme</h3>
<div class="paragraph">
<p>Şu ana kadar yazdığımız script&#8217;ler kendi içine kapanıktı; ne tanımladıysak onu yaptılar. Ancak gerçek hayatta script&#8217;lerimizin dış dünyadan bilgi almasını isteriz. Örneğin, "bu dosyayı yedekle" derken <strong>hangi</strong> dosyayı yedekleyeceğini script&#8217;e söylememiz gerekir.</p>
</div>
<div class="paragraph">
<p>Bunu yapmak için script&#8217;i çalıştırırken yanına değerler (argümanlar) yazarız:
<code>./yedekle.sh rapor.txt</code></p>
</div>
<div class="paragraph">
<p>Bash, bu gönderilen değerleri <code>$1</code>, <code>$2</code>, <code>$3</code> gibi özel değişkenlerde saklar.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>$0</code>: Script&#8217;in kendi adı (Örn: <code>./yedekle.sh</code>)</p>
</li>
<li>
<p><code>$1</code>: İlk argüman</p>
</li>
<li>
<p><code>$2</code>: İkinci argüman</p>
</li>
<li>
<p>&#8230;&#8203; ve böyle dokuza kadar gider.</p>
</li>
<li>
<p><code>$#</code>: Toplam kaç argüman gönderildiğinin sayısı.</p>
</li>
<li>
<p><code>$@</code>: Gönderilen tüm argümanların listesi.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Örnek Uygulama: Selamlama Scripti</strong>
Hemen <code>selamla.sh</code> adında bir dosya oluşturalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

isim=$1
soyisim=$2

echo "Merhaba $isim $soyisim!"
echo "Dosya adı: $0"
echo "Toplam $# argüman aldım."
echo "Tüm argümanlar: $@"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Çalıştıralım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">./selamla.sh Ender Kuş 30 Yazılımcı</code></pre>
</div>
</div>
<div class="paragraph">
<p>Çıktı:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Merhaba Ender Kuş!
Dosya adı: ./selamla.sh
Toplam 4 argüman aldım.
Tüm argümanlar: Ender Kuş 30 Yazılımcı</pre>
</div>
</div>
<div class="paragraph">
<p>Eğer hiç argüman vermezseniz (<code>./selamla.sh</code>), <code>$isim</code> ve <code>$soyisim</code> boş olacağı için sadece "Merhaba !" yazar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_kullanıcıdan_girdi_alma_read_komutu">3.2. Kullanıcıdan Girdi Alma (<code>read</code> komutu)</h3>
<div class="paragraph">
<p>Bazen veriyi script çalışırken kullanıcıya sormak istersiniz. "Adınız nedir?", "Devam etmek istiyor musunuz?" gibi interaktif durumlar için <code>read</code> komutunu kullanırız.</p>
</div>
<div class="paragraph">
<p><strong>Temel Kullanım:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo "Adınızı yazın:"
read isim
echo "Memnun oldum, $isim."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Burada script "Adınızı yazın:" dedikten sonra durur ve kullanıcı bir şey yazıp Enter&#8217;a basana kadar bekler. Yazılan değer <code>isim</code> değişkenine atanır.</p>
</div>
<div class="paragraph">
<p><strong>Daha Pratik Kullanım (<code>-p</code> parametresi):</strong>
<code>echo</code> ile soru sormak yerine <code>read -p</code> (prompt) ile soruyu ve beklemeyi tek satırda yapabiliriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">read -p "Adınız nedir? " isim
echo "Merhaba $isim."</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Gizli Girdi Alma (<code>-s</code> parametresi):</strong>
Şifre gibi ekranda görünmesini istemediğiniz bilgiler için <code>-s</code> (silent) parametresi kullanılır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">read -p "Kullanıcı adı: " k_adi
read -s -p "Şifre: " sifre
echo "" # Alt satıra geçmek için
echo "Giriş yapılıyor..."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu yöntemle script&#8217;lerinizi interaktif ve kullanıcı dostu hale getirebilirsiniz.</p>
</div>
</div>
<div class="sect2">
<h3 id="_argüman_kontrolü_ve_varsayılan_değerler">3.3. Argüman Kontrolü ve Varsayılan Değerler</h3>
<div class="paragraph">
<p>Script&#8217;inize beklediğiniz argümanların gönderilip gönderilmediğini kontrol etmek önemlidir. Eğer kullanıcı argüman göndermeyi unutursa script&#8217;iniz hata verebilir veya -daha kötüsü- yanlış çalışabilir.</p>
</div>
<div class="paragraph">
<p>Bunun için en pratik yöntem, <strong>Varsayılan Değer (Default Value)</strong> atamaktır. Bash&#8217;te bunu yapmak için çok şık bir sözdizimi vardır: <code>${DEGISKEN:-VARSAYILAN}</code>.</p>
</div>
<div class="paragraph">
<p><strong>Kullanımı:</strong>
<code>isim=${1:-Misafir}</code></p>
</div>
<div class="paragraph">
<p>Bu satır şunu demek ister:
"Eğer 1. argüman (<code>$1</code>) varsa, <code>isim</code> değişkenine onu ata. EĞER YOKSA (veya boşsa), <code>isim</code> değişkenine 'Misafir' değerini ata."</p>
</div>
<div class="paragraph">
<p><strong>Örnek: Yedekleme Scripti (Gelişmiş)</strong>
Diyelim ki bir dosyayı yedekleyen script yazıyoruz. Eğer kullanıcı dosya adı vermezse, varsayılan olarak "notlar.txt" dosyasını yedeklesin istiyoruz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

dosya=${1:-notlar.txt}

echo "$dosya dosyası yedekleniyor..."
# (Burada yedekleme komutları olurdu, örneğin cp $dosya $dosya.bak)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Deneyelim:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Argüman vererek: <code>./yedekle.sh rapor.pdf</code></p>
<div class="ulist">
<ul>
<li>
<p>Çıktı: <code>rapor.pdf dosyası yedekleniyor&#8230;&#8203;</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Argüman vermeden: <code>./yedekle.sh</code></p>
<div class="ulist">
<ul>
<li>
<p>Çıktı: <code>notlar.txt dosyası yedekleniyor&#8230;&#8203;</code></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Bu yöntem, karmaşık <code>if</code> yapılarına girmeden (henüz öğrenmedik!) script&#8217;lerinizi daha güvenli ve hataya dayanıklı hale getirmenin en kısa yoludur.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_diziler_arrays">4. Diziler (Arrays)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_dizi_tanımlama">4.1. Dizi Tanımlama</h3>
<div class="paragraph">
<p>Programlamada bazen tek bir değişkende birden fazla veri tutmak isteriz. Örneğin, bir sınıftaki öğrencilerin listesi veya sunucu isimleri gibi. İşte bunun için <strong>Diziler (Arrays)</strong> kullanılır.</p>
</div>
<div class="paragraph">
<p>Bash&#8217;te dizi tanımlamak oldukça basittir. Değerleri parantez <code>()</code> içine alır ve aralarına <strong>boşluk</strong> koyarız.</p>
</div>
<div class="paragraph">
<p><strong>Temel Sözdizimi:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">iller=("İstanbul" "Ankara" "İzmir" "Antalya")
sayilar=(10 20 30 40 50)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Dikkat Edilmesi Gerekenler:</strong>
1.  <strong>Ayırıcı Boşluktur:</strong> Elemanları ayırmak için virgül (<code>,</code>) değil, boşluk kullanılır.
2.  <strong>Boşluklu İsimler:</strong> Eğer eleman kendi içinde boşluk içeriyorsa mutlaka tırnak içine alınmalıdır.
    *   Yanlış: <code>sehirler=(New York San Francisco)</code> &#8594; 4 eleman olur.
    *   Doğru: <code>sehirler=("New York" "San Francisco")</code> &#8594; 2 eleman olur.</p>
</div>
<div class="paragraph">
<p><strong>İndeks Numarası ile Atama:</strong>
Dilerseniz doğrudan belirli bir sıraya da eleman yerleştirebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">meyveler[0]="Elma"
meyveler[1]="Armut"
meyveler[5]="Muz" # Aradaki 2,3,4 boş kalır</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dizi_elemanlarına_erişim">4.2. Dizi Elemanlarına Erişim</h3>
<div class="paragraph">
<p>Bir diziyi tanımladık, peki içindeki verilere nasıl ulaşacağız? Bash&#8217;te diziler "sıfır tabanlıdır" (zero-indexed), yani saymaya 0&#8217;dan başlarız.</p>
</div>
<div class="paragraph">
<p>Dizi elemanlarına erişirken süslü parantez <code>{}</code> kullanımı <strong>zorunludur</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Tek Bir Elemana Erişim:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">iller=("İstanbul" "Ankara" "İzmir" "Antalya" "Bursa")

echo ${iller[0]}  # Çıktı: İstanbul
echo ${iller[1]}  # Çıktı: Ankara</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Tüm Elemanları Yazdırmak:</strong>
Dizinin tamamını görmek için indeks yerine <code>@</code> veya <code>*</code> karakterini kullanırız. Genellikle <code>@</code> tercih edilir çünkü elemanları ayrı ayrı stringler olarak korur.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo ${iller[@]}
# Çıktı: İstanbul Ankara İzmir Antalya Bursa</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Dizi Uzunluğunu (Kaç Eleman Var?) Öğrenmek:</strong>
Dizinin başına <code>#</code> koyarak eleman sayısını alabiliriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo "Toplam il sayısı: ${#iller[@]}"
# Çıktı: Toplam il sayısı: 5</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Belirli Bir Aralığı Almak (Slicing - Dilimleme):</strong>
Dizinin sadece bir kısmını almak istediğinizde <code>${dizi[@]:BAŞLANGIÇ:ADET}</code> formülünü kullanırız. Buradaki mantığı iyi oturtmak önemlidir:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>BAŞLANGIÇ (Offset):</strong> Hangi indisten başlanacak? (0, 1, 2&#8230;&#8203;)</p>
</li>
<li>
<p><strong>ADET (Length):</strong> O noktadan itibaren sağa doğru kaç eleman alınacak?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Örnek üzerinde görelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Dizimiz: ("İstanbul" "Ankara" "İzmir" "Antalya" "Bursa")
# İndeksler:   0          1        2         3        4

# 1. indisten başla (Ankara) ve 2 tane al (Ankara, İzmir)
echo ${iller[@]:1:2}
# Çıktı: Ankara İzmir

# 3. indisten başla (Antalya) ve sonuna kadar git (Adet belirtmezsen sonuna kadar alır)
echo ${iller[@]:3}
# Çıktı: Antalya Bursa</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Diziyi Ters Çevirmek (Reverse):</strong>
Bash&#8217;te diziyi ters çeviren doğrudan bir komut (Python&#8217;daki <code>reverse()</code> gibi) <strong>yoktur</strong>. Ancak Linux&#8217;un gücünü kullanarak bunu yapabiliriz. En pratik yöntemlerden biri, <code>tac</code> (cat&#8217;in tersi) komutunu kullanmaktır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Diziyi satır satır yazdırıp, tac ile ters çeviriyoruz
printf '%s\n' "${iller[@]}" | tac</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Not: Bu işlem dizinin orijinalini değiştirmez, sadece ekrana ters basar. İleride döngüler konusunu işlediğimizde bunu daha kalıcı algoritmalarla nasıl yapacağımızı göreceğiz.</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_diziye_eleman_ekleme_ve_silme">4.3. Diziye Eleman Ekleme ve Silme</h3>
<div class="paragraph">
<p>Diziler statik değildir; sonradan yeni şehirler ekleyebilir veya çıkarabiliriz.</p>
</div>
<div class="paragraph">
<p><strong>Diziye Eleman Ekleme (<code>&#43;=</code> Operatörü):</strong>
Mevcut bir dizinin sonuna yeni elemanlar eklemek için <code>&#43;=</code> operatörü kullanılır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">iller=("İstanbul" "Ankara")
iller+=("İzmir")          # Tek eleman ekleme
iller+=("Antalya" "Bursa") # Çoklu ekleme

echo ${iller[@]}
# Çıktı: İstanbul Ankara İzmir Antalya Bursa</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Diziden Eleman Silme (<code>unset</code>):</strong>
Tıpkı değişkenlerde olduğu gibi <code>unset</code> komutu kullanılır. Ancak burada bir incelik vardır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># 1. indisteki elemanı (Ankara) silelim
unset iller[1]

echo ${iller[@]}
# Çıktı: İstanbul İzmir Antalya Bursa</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Dikkat:</strong> <code>unset</code> ile bir elemanı sildiğinizde, o indeks <strong>boşalır ama kaymaz</strong>. Yani <code>iller[0]</code> İstanbul&#8217;dur, <code>iller[2]</code> İzmir&#8217;dir. <code>iller[1]</code> artık boştur (null). Dizinin indeksi yeniden sıralanmaz.</p>
</div>
<div class="paragraph">
<p>Eğer tamamen temiz, sıralı (1., 2. diye giden) bir dizi istiyorsanız, diziyi yeniden oluşturmalısınız:
<code>iller=( "${iller[@]}" )</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_dizi_üzerinde_i̇şlemler">4.4. Dizi Üzerinde İşlemler</h3>
<div class="paragraph">
<p>Dizilerle sadece ekleme çıkarma değil, elemanların içeriğini değiştirme işlemleri de yapabiliriz.</p>
</div>
<div class="paragraph">
<p><strong>Bul ve Değiştir (Search and Replace):</strong>
Dizi içindeki belirli bir kelimeyi veya harfi değiştirmek için <code>${dizi[@]/aranan/yeni}</code> yapısını kullanırız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">meyveler=("Elma" "Armut" "Muz" "Kara Elma")

# İçinde "Elma" geçen her şeyi "Apple" yapalım
yeni_meyveler=( "${meyveler[@]/Elma/Apple}" )

echo ${yeni_meyveler[@]}
# Çıktı: Apple Armut Muz Kara Apple</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Tek eğik çizgi <code>/</code> kullanırsanız sadece ilk bulduğunu değiştirir.</p>
</li>
<li>
<p>Çift eğik çizgi <code>//</code> kullanırsanız (örneğin <code>${dizi[@]//aranan/yeni}</code>) bulduğu <strong>her şeyi</strong> değiştirir.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Diziyi Kopyalamak:</strong>
Bir diziyi başka bir diziye kopyalamak için:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">kopya_dizi=( "${orijinal_dizi[@]}" )</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu işlem, orijinal dizideki tüm elemanları alır ve yeni bir dizi oluşturur. İndeks boşluklarını (unset kaynaklı) temizlemenin (re-indexing) en kolay yolu da budur.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_aritmetik_i̇şlemler">5. Aritmetik İşlemler</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_let_expr_ve_kullanımı">5.1. <code>let</code>, <code>expr</code> ve <code>(( ))</code> Kullanımı</h3>
<div class="paragraph">
<p>Bash&#8217;te matematiksel işlem yapmanın birden fazla yolu vardır. Tarihsel gelişim içinde farklı yöntemler ortaya çıkmıştır, ancak günümüzde hangisini kullanmanız gerektiğini bilmek önemlidir.</p>
</div>
<div class="paragraph">
<p><strong>1. <code></code> Çift Parantez (Önerilen Yöntem)</strong>
Modern Bash yazımında matematiksel işlemler için altın standart budur. Okunması kolaydır, değişkene <code>$</code> koymadan erişebilirsiniz ve C-tarzı işlemleri destekler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sayi1=10
sayi2=5

((sonuc = sayi1 + sayi2))
echo "Toplama Sonucu: $sonuc"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer sonucu doğrudan yazdırmak isterseniz <code>$(( ))</code> yapısını kullanabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo "Çarpma Sonucu: $(( sayi1 * sayi2 ))"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. <code>let</code> Komutu</strong>
Eski alışkanlıklardan biridir. Hala çalışır ancak <code>(( ))</code> kadar pratik değildir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">let sonuc=sayi1+sayi2</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>3. <code>expr</code> Komutu (Eski ve Yavaş)</strong>
Bash&#8217;in ilk zamanlarından kalma, harici bir programdır. Operatörlerle değişkenler arasında boşluk bırakmak zorundasınızdır.</p>
</div>
<div class="paragraph">
<p>Ayrıca <code>*</code> (yıldız) işareti Bash&#8217;te "tüm dosyalar" anlamına gelen bir joker karakter (wildcard) olduğu için, çarpma işleminde kullanırken başına ters eğik çizgi (<code>\</code>) koyarak onu "kaçırmanız" (escape etmeniz) gerekir. Yani Bash&#8217;e "bunu dosya aramak için değil, sadece çarpma sembolü olarak kullan" demiş olursunuz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sonuc=$(expr $sayi1 + $sayi2)
# expr $sayi1 * $sayi2  -&gt; HATA verir
sonuc=$(expr $sayi1 \* $sayi2) # Doğrusu</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Sonuç:</strong> Mümkün olan her yerde <code>$(( ... ))</code> veya <code>(( ... ))</code> kullanın. Hem daha hızlı hem de daha okunabilirdir.</p>
</div>
</div>
<div class="sect2">
<h3 id="_temel_matematiksel_operatörler">5.2. Temel Matematiksel Operatörler</h3>
<div class="paragraph">
<p><code></code> yapısı içinde standart matematiksel operatörlerin çoğunu kullanabilirsiniz.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>+</code> : Toplama</p>
</li>
<li>
<p><code>-</code> : Çıkarma</p>
</li>
<li>
<p><code>*</code> : Çarpma</p>
</li>
<li>
<p><code>/</code> : Bölme (Dikkat: Sadece tam sayı kısmını verir)</p>
</li>
<li>
<p><code>%</code> : Mod Alma (Kalanı bulma)</p>
</li>
<li>
<p><code>**</code> : Üs Alma (Kuvvet)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Örnekler:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">a=10
b=3

echo "Toplama: $((a + b))"       # 13
echo "Çıkarma: $((a - b))"       # 7
echo "Çarpma:  $((a * b))"       # 30
echo "Bölme:   $((a / b))"       # 3 (10/3 = 3.33 ama Bash tam sayı alır)
echo "Mod:     $((a % b))"       # 1 (10'un 3'e bölümünden kalan)
echo "Üs Alma: $((a ** b))"      # 1000 (10 üzeri 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Artırma ve Azaltma Operatörleri:</strong>
Döngülerde sıkça kullanacağımız C-stili operatörler de geçerlidir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sayi=5
((sayi++))  # Sayıyı 1 artır (6 olur)
((sayi--))  # Sayıyı 1 azalt (5 olur)
((sayi+=10)) # Sayıya 10 ekle (15 olur)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_kayan_noktalı_sayılarla_çalışmak_bc_kullanımı">5.3. Kayan Noktalı Sayılarla Çalışmak (bc kullanımı)</h3>
<div class="paragraph">
<p>Bash, doğası gereği <strong>sadece tam sayılarla (integers)</strong> çalışır. Ondalıklı sayılar, yani programlama dünyasındaki adıyla <strong>float</strong> (floating point numbers) veri tipi Bash&#8217;in matematiğinde doğrudan desteklenmez. Eğer <code>10 / 3</code> işlemini Bash&#8217;e yaptırırsanız <code>3.33</code> değil, sadece <code>3</code> sonucunu alırsınız.</p>
</div>
<div class="paragraph">
<p>Ondalıklı (virgüllü/float) sayılarla işlem yapmak için harici bir hesap makinesine ihtiyacımız vardır. En yaygın kullanılan araç <strong><code>bc</code> (Basic Calculator)</strong> programıdır.</p>
</div>
<div class="paragraph">
<p><strong>Kullanımı:</strong>
Matematiksel ifadenizi <code>echo</code> ile <code>bc&#8217;ye "pipe" (</code>|`) yaparak göndeririz.</p>
</div>
<div class="paragraph">
<p><strong>Temel Kural ve <code>scale</code>:</strong>
<code>bc</code> varsayılan olarak <code>scale=0</code> ayarıyla çalışır, yani bölme işlemlerinde ondalık kısmı atar. Hassas sonuçlar almak için <code>scale</code> değerini (virgülden sonra kaç hane istediğinizi) belirtmeniz gerekir.</p>
</div>
<div class="paragraph">
<p>Örneğin, <code>scale=2</code> derseniz, sonuçlar virgülden sonra 2 basamaklı (örn: 3.33) hesaplanır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo "10 / 3" | bc
# Çıktı: 3 (Hala tam sayı)

echo "scale=2; 10 / 3" | bc
# Çıktı: 3.33</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Değişkenlerle Kullanım:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">a=10.5
b=2.5

# Bash bunu yapamaz: (( sonuc = a + b )) -&gt; HATA!

# bc ile yapalım:
sonuc=$(echo "$a + $b" | bc)
echo "Sonuç: $sonuc" # Çıktı: 13.0</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Karşılaştırmalarda bc Kullanımı:</strong>
Bazen ondalıklı sayıları karşılaştırmanız da gerekebilir. <code>bc</code>, doğruysa <code>1</code>, yanlışsa <code>0</code> sonucu döner.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># 10.5 &gt; 2.5 mi? (Evet -&gt; 1)
echo "$a &gt; $b" | bc
# Çıktı: 1

# 2.5 &gt; 10.5 mi? (Hayır -&gt; 0)
echo "$b &gt; $a" | bc
# Çıktı: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu sonuçları ileride göreceğimiz <strong>if</strong> yapılarında kullanarak mantıksal kararlar alabileceğiz.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_metin_string_i̇şlemleri">6. Metin (String) İşlemleri</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_string_birleştirme_concatenation">6.1. String Birleştirme (Concatenation)</h3>
<div class="paragraph">
<p>Bash&#8217;te iki veya daha fazla metni birleştirmek (concatenation) diğer dillerdeki gibi <code>+</code> işaretiyle yapılmaz. Bash&#8217;te metinleri <strong>yan yana yazmanız</strong> yeterlidir.</p>
</div>
<div class="paragraph">
<p><strong>Temel Kullanım:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">isim="Ender"
soyisim="Kuş"

# Yan yana yazarak birleştirme
tam_isim="$isim $soyisim"

echo $tam_isim
# Çıktı: Ender Kuş</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Araya Karakter Ekleyerek Birleştirme:</strong>
Değişkenlerin arasına tire, nokta veya başka stringler koyabilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dosya_adi="rapor"
uzanti="txt"
tarih="2025-12-29"

tam_dosya_adi="${dosya_adi}-${tarih}.${uzanti}"

echo $tam_dosya_adi
# Çıktı: rapor-2025-12-29.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Önemli İpucu:</strong> Değişkenleri birleştirirken her zaman çift tırnak <code>""</code> ve süslü parantez <code>${}</code> kullanmak, boşluk içeren dosya isimlerinde veya karışık stringlerde hata yapmanızı önler.</p>
</div>
</div>
<div class="sect2">
<h3 id="_string_uzunluğunu_alma">6.2. String Uzunluğunu Alma</h3>
<div class="paragraph">
<p>Bir metnin kaç karakterden oluştuğunu (boşluklar dahil) öğrenmek için <code>${#degisken}</code> yapısı kullanılır.</p>
</div>
<div class="paragraph">
<p>Bu yapı, aslında değişkenin "içeriğinin sayısını" verir. Dizilerde (<code>${#dizi[@]}</code>) eleman sayısını veriyordu, stringlerde ise karakter sayısını verir.</p>
</div>
<div class="paragraph">
<p><strong>Örnek:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">parola="Gizli123"

echo "Parola uzunluğu: ${#parola}"
# Çıktı: Parola uzunluğu: 8</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Kullanım Alanı:</strong>
Genellikle parola geçerliliği kontrol ederken (örneğin "en az 8 karakter olmalı") veya metin hizalama işlemlerinde kullanılır.</p>
</div>
</div>
<div class="sect2">
<h3 id="_alt_metin_substring_alma">6.3. Alt Metin (Substring) Alma</h3>
<div class="paragraph">
<p>Bir metnin içinden belirli bir parçayı kesip almak için dizilerde kullandığımız yöntemin aynısını kullanırız: <code>${degisken:başlangıç:uzunluk}</code>.</p>
</div>
<div class="paragraph">
<p><strong>Temel Sözdizimi:</strong>
*   <strong>Başlangıç (Offset):</strong> Kaçıncı karakterden başlanacak? (0&#8217;dan başlar)
*   <strong>Uzunluk (Length):</strong> Kaç karakter alınacak? (Belirtilmezse sona kadar gider)</p>
</div>
<div class="paragraph">
<p><strong>Örnek:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">metin="LinuxDünyası"

# 0. karakterden başla, 5 karakter al
echo ${metin:0:5}
# Çıktı: Linux

# 5. karakterden başla, sona kadar git
echo ${metin:5}
# Çıktı: Dünyası

# Sondan Veri Alma (Negatif İndeks)
# Sondan 3 karakteri almak için (boşluk bırakmaya dikkat!)
echo ${metin: -3}
# Çıktı: ası</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metin_arama_ve_değiştirme">6.4. Metin Arama ve Değiştirme</h3>
<div class="paragraph">
<p>Bir string içindeki belirli kelimeleri veya harfleri değiştirmek için <code>${degisken/eski/yeni}</code> yapısı kullanılır.</p>
</div>
<div class="paragraph">
<p><strong>Kurallar:</strong>
1.  <code>${degisken/aranan/yeni}</code> &#8594; Sadece <strong>ilk</strong> bulduğunu değiştirir.
2.  <code>${degisken//aranan/yeni}</code> &#8594; Bulduğu <strong>tüm</strong> eşleşmeleri değiştirir (Global replace).
3.  <code>${degisken/aranan}</code> &#8594; Aranan ifadeyi <strong>siler</strong> (Yeni değer boş olduğu için).</p>
</div>
<div class="paragraph">
<p><strong>Örnek:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cumle="Kedi çok tatlı bir hayvandır. Kedi mırlar."

# İlk 'Kedi'yi 'Köpek' yap
echo ${cumle/Kedi/Köpek}
# Çıktı: Köpek çok tatlı bir hayvandır. Kedi mırlar.

# Tüm 'Kedi'leri 'Köpek' yap
echo ${cumle//Kedi/Köpek}
# Çıktı: Köpek çok tatlı bir hayvandır. Köpek mırlar.

# 'tatlı ' kelimesini sil
echo ${cumle/tatlı }
# Çıktı: Kedi çok bir hayvandır. Kedi mırlar.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_büyükküçük_harf_dönüşümleri">6.5. Büyük/Küçük Harf Dönüşümleri</h3>
<div class="paragraph">
<p>Bash 4.0 ve sonrasında gelen çok pratik bir özellik sayesinde harfleri büyütebilir veya küçültebilirsiniz.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>^</code>: Sadece baş harfi büyütür.</p>
</li>
<li>
<p><code>^^</code>: Tüm harfleri büyütür.</p>
</li>
<li>
<p><code>,</code>: Sadece baş harfi küçültür.</p>
</li>
<li>
<p><code>,,</code>: Tüm harfleri küçültür.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Örnek:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sehir="istanbul"
kod="TR-ANT"

echo ${sehir^}   # İstanbul (Baş harf büyük)
echo ${sehir^^}  # İSTANBUL (Hepsi büyük)

echo ${kod,}     # tR-ANT (Baş harf küçük)
echo ${kod,,}    # tr-ant (Hepsi küçük)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu özellik, özellikle kullanıcı girdilerini standart hale getirmek (case-insensitive karşılaştırma yapmak) için çok kullanışlıdır.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_karar_yapıları_decision_making">7. Karar Yapıları (Decision Making)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_if_else_elif_yapıları">7.1. <code>if</code>, <code>else</code>, <code>elif</code> Yapıları</h3>
<div class="paragraph">
<p>Bash&#8217;in karar verme mekanizması <code>if</code> (eğer) bloğudur. Bir koşulu kontrol eder ve bu koşul <strong>doğruysa (true)</strong> bloğun içindeki komutları çalıştırır.</p>
</div>
<div class="paragraph">
<p><strong>Temel Sözdizimi:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">if [ KOŞUL ]; then
    # Koşul doğruysa burası çalışır
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Not: Köşeli parantezlerin <code>[ ]</code> içinde ve etrafında BOŞLUK bırakmak zorunludur!</strong></p>
</div>
<div class="paragraph">
<p><strong><code>else</code> (Değilse) Kullanımı:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">if [ KOŞUL ]; then
    # Doğruysa
else
    # Yanlışsa
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><code>elif</code> (Else If - Değilse Eğer) Kullanımı:</strong>
Birden fazla koşulu sırayla kontrol etmek için kullanılır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">yas=18

if [ $yas -lt 18 ]; then
    echo "Çocuksunuz."
elif [ $yas -eq 18 ]; then
    echo "Tam sınırda, 18 yaşındasınız."
else
    echo "Yetişkinsiniz."
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu yapı, script&#8217;lerinizin sadece düz bir çizgi gibi değil, duruma göre farklı yollara sapan akıllı programlar olmasını sağlar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_test_operatörleri">7.2. Test Operatörleri</h3>
<div class="paragraph">
<p><code>if</code> bloklarında neyi kontrol edeceğiz? İşte burada <strong>Test Operatörleri</strong> devreye girer. Üç ana kategoride incelenir:</p>
</div>
<div class="paragraph">
<p><strong>1. Sayısal Karşılaştırma:</strong>
*   <code>-eq</code> : Eşittir (Equal)
*   <code>-ne</code> : Eşit değildir (Not Equal)
*   <code>-gt</code> : Büyüktür (Greater Than)
*   <code>-lt</code> : Küçüktür (Less Than)
*   <code>-ge</code> : Büyük eşittir (Greater or Equal)
*   <code>-le</code> : Küçük eşittir (Less or Equal)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">if [ $sayi -gt 10 ]; then ... fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. Metin (String) Karşılaştırma:</strong>
*   <code>==</code> : Eşittir
*   <code>!=</code> : Eşit değildir
*   <code>-z</code> : String BOŞTUR (Zero length) &#8594; Çok sık kullanılır!
*   <code>-n</code> : String DOLUDUR (Non-zero length)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ad="Ender"
if [ "$ad" == "Ender" ]; then ... fi

# Kullanıcı ad girmemiş mi kontrolü:
if [ -z "$isim" ]; then
    echo "Lütfen bir isim girin!"
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>3. Dosya Kontrol Operatörleri:</strong>
En güçlü kısımdır. Dosyalar ve dizinler hakkında bilgi verir.
*   <code>-e</code> : Dosya veya dizin VAR MI? (Exist)
*   <code>-d</code> : Bir DİZİN mi? (Directory)
*   <code>-f</code> : Normal bir DOSYA mı? (File)
*   <code>-r</code> : Okunabilir mi? (Readable)
*   <code>-w</code> : Yazılabilir mi? (Writable)
*   <code>-x</code> : Çalıştırılabilir mi? (Executable)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dosya="rapor.txt"
if [ -f "$dosya" ]; then
    echo "Dosya mevcut, üzerine yazılıyor..."
else
    echo "Hata: Dosya bulunamadı!"
fi</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mantıksal_operatörler_and_or_not">7.3. Mantıksal Operatörler (AND, OR, NOT)</h3>
<div class="paragraph">
<p>Birden fazla koşulu aynı anda kontrol etmek istediğimizde mantıksal operatörler devreye girer.</p>
</div>
<div class="paragraph">
<p><strong>1. AND (VE) Operatörü (<code>-a</code> veya <code>&amp;&amp;</code>):</strong>
Her iki koşul da doğru olmalıdır.
Not: <code>[[ &#8230;&#8203; ]]</code> yapısı içinde <code>&amp;&amp;</code> kullanmak daha moderndir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">yas=25
ehliyet="var"

if [[ $yas -ge 18 &amp;&amp; "$ehliyet" == "var" ]]; then
    echo "Araba kiralayabilirsiniz."
else
    echo "Üzgünüm, şartları sağlamıyorsunuz."
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. OR (VEYA) Operatörü (<code>-o</code> veya <code>||</code>):</strong>
İki koşuldan sadece birinin doğru olması yeterlidir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">gun="Cumartesi"

if [[ "$gun" == "Cumartesi" || "$gun" == "Pazar" ]]; then
    echo "Haftasonu tatili!"
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>3. NOT (DEĞİL) Operatörü (<code>!</code>):</strong>
Bir koşulun tersini alır. Doğruysa yanlış, yanlışsa doğru yapar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">if [ ! -f "config.ini" ]; then
    echo "Config dosyası EKSİK! Oluşturuluyor..."
    touch config.ini
fi</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_case_yapısı_ile_çoklu_seçim">7.4. <code>case</code> Yapısı ile Çoklu Seçim</h3>
<div class="paragraph">
<p>Eğer bir değişkenin alabileceği değerlere göre çok fazla <code>elif</code> bloğu yazmanız gerekiyorsa, <code>case</code> yapısı çok daha temiz bir alternatiftir.</p>
</div>
<div class="paragraph">
<p>Genellikle menü seçimlerinde veya komut satırı argümanlarını (ör: start, stop, restart) işlerken kullanılır.</p>
</div>
<div class="paragraph">
<p><strong>Sözdizimi:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">read -p "Bir meyve seçin (elma/armut/muz): " meyve

case $meyve in
    "elma")
        echo "Elma kırmızıdır."
        ;;
    "armut")
        echo "Armut sarıdır."
        ;;
    "muz")
        echo "Muz uzundur."
        ;;
    *)
        echo "Bilinmeyen meyve: $meyve"
        ;;
esac</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Önemli Detaylar:</strong>
1.  Her seçenekten sonra parantez <code>)</code> konur.
2.  Yapılacak işlemlerden sonra çift noktalı virgül <code>;;</code> ile o bloğun bittiği belirtilir.
3.  <code>*)</code> (yıldız), diğer hiçbir şeye uymayan durumlar için "varsayılan" (default) seçenektir (else gibi davranır).
4.  <code>esac</code> (case&#8217;in tersi) ile yapı kapatılır.</p>
</div>
</div>
<div class="sect2">
<h3 id="_karmaşık_senaryolar_ve_pekiştirme_örnekleri">7.5. Karmaşık Senaryolar ve Pekiştirme Örnekleri</h3>
<div class="paragraph">
<p>Karar yapıları (Decision Making) konusunu iyice pekiştirmek için, basitten karmaşığa doğru giden gerçekçi örnekler yapalım.</p>
</div>
<div class="paragraph">
<p><strong>Örnek 1: Basit Şifre Kontrolü (String Karşılaştırma)</strong>
Kullanıcıdan gizli bir şifre isteyelim ve doğru olup olmadığına bakalım. Bu örnekte <code>-s</code> parametresini ve string eşitliğini hatırlayalım.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">read -s -p "Lütfen parolayı girin: " parola
echo "" # Alt satıra geçmek için

if [ "$parola" == "SuperSecret123" ]; then
    echo "Giriş başarılı! Hoş geldin."
else
    echo "Hatalı parola! Erişim reddedildi."
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Örnek 2: Ondalıklı Sayı Karşılaştırma (<code>bc</code> ile)</strong>
Bölüm 5&#8217;te bahsettiğimiz <code>bc</code> komutunu artık <code>if</code> içinde kullanabiliriz. Bash normalde <code>10.5</code> gibi sayıları anlamaz, ama <code>bc</code> sayesinde bunları kıyaslayabiliriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">a=10.5
b=5.3

# bc -l komutu, karşılaştırma doğruysa 1, yanlışsa 0 döner.
if (( $(echo "$a &gt; $b" | bc -l) )); then
    echo "$a sayısı $b sayısından BÜYÜKTÜR."
else
    echo "$a sayısı $b sayısından KÜÇÜKTÜR veya EŞİTTİR."
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Örnek 3: Yedekleme Aracı (Dosya Kontrolleri)</strong>
Kullanıcıdan bir dosya adı alacağız. Varsa yedekleyeceğiz, yoksa uyaracağız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

dosya=${1:-varsayilan.txt}

if [ -f "$dosya" ]; then
    echo "Dosya bulundu: $dosya"
    # Yedekleme işlemi
    cp "$dosya" "$dosya.bak" &amp;&amp; echo "Yedekleme başarılı!"

elif [ -d "$dosya" ]; then
    echo "Hata: '$dosya' bir klasör! Sadece dosyaları yedekleyebilirim."

else
    echo "Hata: '$dosya' bulunamadı!"
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Örnek 4: Gelişmiş Hesap Makinesi</strong>
Tüm öğrendiklerimizi (case, regex kontrolü, aritmetik) birleştiren kapsamlı bir senaryo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

echo "Hesap Makinesine Hoş Geldiniz"
read -p "1. Sayı: " s1
read -p "İşlem (+, -, *, /): " islem
read -p "2. Sayı: " s2

# Basit bir regex ile sayı kontrolü
if [[ ! "$s1" =~ ^[0-9]+$ || ! "$s2" =~ ^[0-9]+$ ]]; then
    echo "Hata: Lütfen geçerli tam sayılar girin."
    exit 1
fi

case $islem in
    +)  echo "Sonuç: $((s1 + s2))" ;;
    -)  echo "Sonuç: $((s1 - s2))" ;;
    *)  # Çarpma (*) işaretini escape ediyoruz
        echo "Sonuç: $((s1 * s2))" ;;
    /)
        if [ $s2 -eq 0 ]; then
            echo "Hata: Sıfıra bölme!"
        else
            # bc ile ondalıklı bölme
            echo "Sonuç: $(echo "scale=2; $s1 / $s2" | bc)"
        fi
        ;;
    *)  echo "Geçersiz işlem!" ;;
esac</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_döngüler">8. Döngüler</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_for_döngüsü">8.1. <code>for</code> Döngüsü</h3>
<div class="paragraph">
<p><strong>Döngü Nedir?</strong>
Döngüler, belirli bir işlemi tekrar tekrar yapmamızı sağlayan yapılardır. "Bu komutu 100 kere çalıştır" veya "Şu klasördeki tüm dosyalar için sırayla şu işlemi yap" gibi görevler için döngüleri kullanırız. Elle tek tek yazmak yerine, döngüye bir kere tarif ederiz, o bizim yerimize defalarca çalıştırır.</p>
</div>
<div class="paragraph">
<p>Bash&#8217;te <code>for</code> döngüsünün iki temel kullanım şekli vardır.</p>
</div>
<div class="paragraph">
<p><strong>1. Liste Üzerinde Gezinme (Standart Bash Tarzı):</strong>
Bash&#8217;in en doğal ve sık kullanılan döngü türüdür. Bir kelime listesinin, dosya grubunun veya komut çıktısının üzerinde tek tek gezinmek için kullanılır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Basit Liste: 'isim' değişkeni sırayla Ali, Ayşe ve Ahmet değerlerini alır.
for isim in Ali Ayşe Ahmet; do
    echo "Merhaba $isim"
done</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Aralık Belirtme:</strong> <code>{başlangıç..bitiş}</code> yapısı ile sayı aralığı verebilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">for sayi in {1..5}; do
    echo "Sayı: $sayi"
done</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. C-Tarzı <code>for</code> Döngüsü:</strong>
Eğer C, Java, PHP veya JavaScript gibi dillerden geliyorsanız bu yapı size çok tanıdık gelecektir. Genellikle matematiksel sayaçlar için kullanılır.</p>
</div>
<div class="paragraph">
<p>Bu yapıda <strong>Çift Parantez <code>(( ... ))</code></strong> kullanılır ve 3 bölümden oluşur:
1.  <strong>Başlangıç (Initialization):</strong> Döngü hangi sayıdan başlayacak? (<code>i=1</code>)
2.  <strong>Koşul (Condition):</strong> Döngü ne zamana kadar dönecek? (<code>i&#8656;5</code>, yani i 5&#8217;ten küçük veya eşit olduğu sürece)
3.  <strong>Artış (Increment):</strong> Her adımda sayaç nasıl değişecek? (<code>i++</code>, yani i&#8217;yi 1 artır)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># i=1'den başla; i 5'e eşit veya küçükse devam et; her turda i'yi 1 artır.
for (( i=1; i&lt;=5; i++ )); do
    echo "Sayaç: $i"
done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu yapı, özellikle "Listenin 3. elemanından başla, ikişer ikişer git" gibi karmaşık matematiksel döngüler kurarken <code>for i in {1..100..2}</code> yapısına göre daha esnek olabilir.</p>
</div>
</div>
<div class="sect2">
<h3 id="_while_ve_until_döngüleri">8.2. <code>while</code> ve <code>until</code> Döngüleri</h3>
<div class="paragraph">
<p>Koşula bağlı döngülerdir.</p>
</div>
<div class="paragraph">
<p><strong>1. <code>while</code> Döngüsü:</strong>
Koşul <strong>doğru olduğu sürece</strong> döner. (While = -iken, süresince)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sayac=1

while [ $sayac -le 5 ]; do
    echo "Sayac: $sayac"
    ((sayac++)) # Sayacı artırmayı unutmayın, yoksa sonsuz döngü olur!
done</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Sonsuz Döngü:</strong>
Genellikle servisleri veya sürekli çalışan scriptleri yazarken kullanılır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">while true; do
    echo "Çalışıyorum..."
    sleep 1 # 1 saniye bekle
done</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. <code>until</code> Döngüsü:</strong>
Koşul <strong>doğru OLANA KADAR</strong> döner. Yani koşul yanlışken çalışır, doğru olunca durur. (Until = -e kadar)
`while&#8217;ın tam tersidir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">sayi=10

# Sayı 0'a eşit OLANA KADAR dön
until [ $sayi -eq 0 ]; do
    echo "Geri sayım: $sayi"
    ((sayi--))
done</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_döngü_kontrolü_break_ve_continue">8.3. Döngü Kontrolü: <code>break</code> ve <code>continue</code></h3>
<div class="paragraph">
<p>Bazen döngü bitmeden çıkmak veya o anki adımı atlamak isteriz.</p>
</div>
<div class="paragraph">
<p><strong>1. <code>break</code>: Döngüyü Kırıp Çık</strong>
Aradığımız bir şeyi bulduğumuzda döngünün geri kalanını çalıştırmaya gerek yoktur.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">for sayi in {1..10}; do
    if [ $sayi -eq 5 ]; then
        echo "5 bulundu! Çıkılıyor..."
        break
    fi
    echo "Sayı: $sayi"
done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Çıktı sadece 1&#8217;den 4&#8217;e kadar sayıları basar, 5&#8217;i bulunca "5 bulundu!" der ve çıkar.</p>
</div>
<div class="paragraph">
<p><strong>2. <code>continue</code>: Sadece Bu Adımı Atla</strong>
Döngüyü kırmaz, sadece o anki iterasyonu (turu) pas geçer ve bir sonraki tura geçer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">for sayi in {1..5}; do
    if [ $sayi -eq 3 ]; then
        echo "3'ü atlıyorum..."
        continue
    fi
    echo "İşlenen sayı: $sayi"
done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Çıktıda 3 hariç diğer tüm sayılar (1, 2, 4, 5) görünür.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dosya_satırlarını_okuma_döngüsü">8.4. Dosya Satırlarını Okuma Döngüsü</h3>
<div class="paragraph">
<p>Bir dosyanın içeriğini satır satır okuyup işlem yapmak, sistem yönetiminde en sık yapılan işlerden biridir. Bunu <code>while</code> döngüsü ve <code>read</code> komutu ile yaparız.</p>
</div>
<div class="paragraph">
<p><strong>Temel Kalıp:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">while read -r satir; do
    echo "Okunan satır: $satir"
done &lt; "dosya.txt"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Neden <code>-r</code>?</strong>
<code>read</code> komutuna <code>-r</code> parametresini vermek, ters eğik çizgi (<code>\</code>) karakterinin kaçış karakteri olarak yorumlanmasını engeller. Dosyadaki veriyi olduğu gibi okumak için her zaman <code>-r</code> kullanmak en güvenli yoldur.</p>
</div>
<div class="paragraph">
<p><strong>Örnek Uygulama:</strong>
<code>sunucular.txt</code> adında bir dosyamız olsun ve içinde sunucu IP&#8217;leri bulunsun. Her birine ping atmak istiyoruz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dosya="sunucular.txt"

# Dosya var mı kontrol edelim
if [ ! -f "$dosya" ]; then
    echo "Hata: $dosya bulunamadı."
    exit 1
fi

while read -r ip; do
    echo "Ping atılıyor: $ip"
    ping -c 1 "$ip" &amp;&gt; /dev/null # Çıktıyı gizle

    if [ $? -eq 0 ]; then
        echo "  -&gt; $ip ERIŞILEBILIR."
    else
        echo "  -&gt; $ip ERIŞILEMEZ!"
    fi
done &lt; "$dosya"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu yapı, yüzlerce sunucuyu tek komutla kontrol etmenizi sağlar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_döngüler_i̇çin_pekiştirme_örnekleri">8.5. Döngüler İçin Pekiştirme Örnekleri</h3>
<div class="paragraph">
<p>Döngüler konusunu daha iyi kavramak için günlük hayatta işinize yarayacak pratik senaryolar hazırladık.</p>
</div>
<div class="paragraph">
<p><strong>Senaryo 1: Toplu Dosya Uzantısı Değiştirme</strong>
Elimizde <code>.htm</code> uzantılı birçok dosya var ve bunları <code>.html</code> yapmak istiyoruz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

echo "Dönüştürme başlıyor..."

for dosya in *.htm; do
    # Eğer hiç .htm dosyası yoksa döngü *.htm diye ham string döner, bunu engellemek için:
    [ -e "$dosya" ] || continue

    # ${degisken%desen} yapısı ile sondaki .htm'i atıp yeni isim oluşturuyoruz
    yeni_isim="${dosya%.htm}.html"

    mv "$dosya" "$yeni_isim"
    echo "$dosya -&gt; $yeni_isim olarak değiştirildi."
done</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Senaryo 2: Geri Sayım Aracı (Until Kullanımı)</strong>
Kullanıcıdan bir saniye değeri alıp geri sayan bir araç.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

read -p "Kaç saniye geri sayayım? " saniye

until [ $saniye -lt 1 ]; do
    echo "$saniye..."
    sleep 1
    ((saniye--))
done

echo "Süre doldu! 🚀"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Senaryo 3: Kullanıcı Oluşturma (Dosyadan Okuma)</strong>
<code>kullanicilar.txt</code> dosyasındaki isimleri okuyup sisteme ekleyen (simülasyon) bir script.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">while read -r kullanici; do
    # Boş satırları atla
    if [ -z "$kullanici" ]; then continue; fi

    echo "Kullanıcı oluşturuluyor: $kullanici"
    # sudo useradd -m "$kullanici" (Gerçek kullanım için bu satırı açın)
    echo "  -&gt; $kullanici eklendi."

done &lt; "kullanicilar.txt"</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Bu örnekler, döngülerin sadece sayı saymak için değil, dosya sistemi ve sistem yönetimi için ne kadar güçlü olduğunu göstermektedir.</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fonksiyonlar">9. Fonksiyonlar</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_fonksiyon_tanımlama_ve_çağırma">9.1. Fonksiyon Tanımlama ve Çağırma</h3>
<div class="paragraph">
<p>Yazılım dünyasında altın bir kural vardır: <strong>DRY (Don&#8217;t Repeat Yourself)</strong>, yani "Kendini Tekrar Etme". Eğer bir script içinde aynı kodu iki veya daha fazla kez yazıyorsanız, onu bir <strong>fonksiyon</strong> haline getirmelisiniz.</p>
</div>
<div class="paragraph">
<p>Fonksiyonlar, karmaşık scriptleri küçük, yönetilebilir ve anlaşılır parçalara böler.</p>
</div>
<div class="paragraph">
<p><strong>Tanımlama Yöntemleri:</strong>
Bash&#8217;te fonksiyon tanımlamanın iki yolu vardır. İkisi de aynı işi yapar, ancak yazım farkı vardır.</p>
</div>
<div class="paragraph">
<p><strong>Yöntem 1: Standart (POSIX) ve Önerilen</strong>
En yaygın ve taşınabilir yöntem budur. <code>function</code> kelimesi kullanılmaz, sadece parantez <code>()</code> yeterlidir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">selamla() {
    echo "Merhaba Dünya!"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Yöntem 2: <code>function</code> Anahtar Kelimesi ile</strong>
Bazı programcılar daha okunaklı bulduğu için bunu kullanır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">function selamla {
    echo "Merhaba Dünya!"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Fonksiyon İsimlendirme:</strong>
Fonksiyon isimleri açıklayıcı olmalıdır. Genellikle küçük harf ve kelime aralarında alt çizgi (<code>snake_case</code>) kullanılır (örn: <code>dosya_kontrol_et</code>, <code>log_yaz</code>).</p>
</div>
<div class="paragraph">
<p><strong>Çağırma (Çalıştırma):</strong>
Fonksiyonu tanımladığınızda kod hemen çalışmaz; sadece hafızaya alınır. Çalıştırmak için script&#8217;in ana akışında ismini yazmalısınız.</p>
</div>
<div class="paragraph">
<p><strong>Önemli Kurallar:</strong>
1.  <strong>Parantez Yok:</strong> Çağırırken <code>selamla()</code> değil, sadece <code>selamla</code> yazılır.
2.  <strong>Sıralama:</strong> Bash scriptleri yukarıdan aşağıya okunur. Fonksiyonu <strong>çağırmadan ÖNCE</strong> tanımlamalısınız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

# HATA! Bash henüz 'baslat' diye bir şey bilmiyor.
# baslat

baslat() {
    echo "Sistem başlatılıyor..."
}

# DOĞRU: Tanımlandıktan sonra çağrılır.
baslat</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fonksiyonlara_parametre_gönderme">9.2. Fonksiyonlara Parametre Gönderme</h3>
<div class="paragraph">
<p>Diğer programlama dillerinde fonksiyon parametreleri parantez içinde tanımlanır (<code>func(a, b)</code> gibi). <strong>Bash&#8217;te ise durum farklıdır.</strong></p>
</div>
<div class="paragraph">
<p>Bash fonksiyonlarına parametreler, tıpkı script&#8217;e argüman gönderir gibi gönderilir. Fonksiyon içinde bu parametrelere <code>$1</code>, <code>$2</code> gibi özel değişkenlerle erişilir.</p>
</div>
<div class="paragraph">
<p><strong>Örnek:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

# Fonksiyon Tanımı
topla() {
    sayi1=$1
    sayi2=$2

    echo "Toplam: $((sayi1 + sayi2))"
}

# Fonksiyonu Çağırma (Parametreleri yanına yazıyoruz)
topla 10 20
topla 5 8</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Dikkat:</strong>
Fonksiyon içindeki <code>$1</code>, script&#8217;e gönderilen <code>$1</code> (ana argüman) ile karışmaz. Fonksiyon çalıştığı süre boyunca <code>$1</code>, fonksiyona gönderilen ilk parametredir.</p>
</div>
</div>
<div class="sect2">
<h3 id="_return_değeri_ve_exit_status">9.3. Return Değeri ve Exit Status</h3>
<div class="paragraph">
<p>Bash&#8217;e yeni başlayanların en çok karıştırdığı nokta "Return" (Dönüş) kavramıdır. Diğer dillerde (Python, Java vb.) <code>return "Sonuç"</code> diyerek metin veya nesne döndürebilirsiniz. <strong>Bash&#8217;te bu MÜMKÜN DEĞİLDİR.</strong></p>
</div>
<div class="paragraph">
<p>Bash&#8217;te bir fonksiyonun dış dünyaya veri iletmesinin iki yolu vardır:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Exit Status (Çıkış Kodu):</strong> Başarı <code>0</code> veya hata durumunu <code>1-255</code> bildirmek için. (<code>return</code> komutu ile)</p>
</li>
<li>
<p><strong>Standart Çıktı (Stdout):</strong> Gerçek veriyi (metin, sayı) göndermek için. (<code>echo</code> komutu ile)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>1. <code>return</code> ile Durum Bildirme:</strong>
<code>return</code> komutu sadece <strong>0 ile 255</strong> arasında bir tam sayı döndürebilir. Bu, "Fonksiyon görevini başarıyla tamamladı mı?" sorusunun cevabıdır.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>return 0</code>: Başarılı (True gibi düşünün)</p>
</li>
<li>
<p><code>return 1</code> (veya üzeri): Hata (False gibi düşünün)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dosya_kontrol() {
    if [ -f "$1" ]; then
        return 0 # Başarılı
    else
        return 1 # Hata
    fi
}

dosya_kontrol "rapor.txt"

# $? değişkeni son çalışan komutun/fonksiyonun çıkış kodunu verir.
if [ $? -eq 0 ]; then
    echo "Dosya mevcut."
else
    echo "Dosya yok!"
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. String Döndürmek için <code>echo</code> Trick&#8217;i:</strong>
Eğer fonksiyonun bir veri (string, hesaplama sonucu vb.) üretmesini istiyorsanız, bunu <code>echo</code> ile basıp, fonksiyonu çağırırken Command Substitution <code>$(&#8230;&#8203;)</code> kullanmalısınız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">buyuk_harf_yap() {
    local metin="$1"
    echo "${metin^^}"
}

# Fonksiyonun çıktısını değişkene atıyoruz
sonuc=$(buyuk_harf_yap "merhaba")
echo "Dönülen değer: $sonuc"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu yöntem Bash scriptlerinde "değer döndürme"nin (return value) standart yoludur.</p>
</div>
</div>
<div class="sect2">
<h3 id="_değişken_kapsamı_local_vs_global">9.4. Değişken Kapsamı (Local vs Global)</h3>
<div class="paragraph">
<p>Bash&#8217;te varsayılan olarak bir fonksiyon içinde tanımladığınız değişken <strong>GLOBAL</strong> olur. Yani fonksiyon bittikten sonra bile o değişkene dışarıdan erişilebilir ve bu durum istenmeyen hatalara yol açabilir.</p>
</div>
<div class="paragraph">
<p>Bunu engellemek için <code>local</code> anahtar kelimesi kullanılır.</p>
</div>
<div class="paragraph">
<p><strong>Hatalı Kullanım (Global):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">isim="Ender"

degistir() {
    isim="Ali" # Global olan 'isim' değişkenini ezer!
}

degistir
echo $isim
# Çıktı: Ali (Orijinal değer bozuldu!)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Doğru Kullanım (Local):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">isim="Ender"

degistir() {
    local isim="Ali" # Sadece bu fonksiyon içinde geçerli yeni bir değişken
    echo "Fonksiyon içi: $isim"
}

degistir
echo "Fonksiyon dışı: $isim"
# Çıktı:
# Fonksiyon içi: Ali
# Fonksiyon dışı: Ender (Korundu!)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Kural:</strong> Fonksiyon içinde tanımladığınız her değişkenin başına mutlaka <code>local</code> koyun.</p>
</div>
</div>
<div class="sect2">
<h3 id="_kütüphane_oluşturma_ve_source_kullanımı">9.5. Kütüphane Oluşturma ve <code>source</code> Kullanımı</h3>
<div class="paragraph">
<p>Büyük projelerde tüm fonksiyonları tek bir dosyaya yazmak yönetimi zorlaştırır. Bunun yerine fonksiyonları ayrı dosyalara (kütüphanelere) yazıp ana script&#8217;ten çağırabiliriz.</p>
</div>
<div class="paragraph">
<p>Örneğin <code>utils.sh</code> adında bir dosyamız olsun:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># utils.sh dosyasi
log_yaz() {
    echo "[LOG] $1"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ana scriptimizden (<code>main.sh</code>) bunu kullanmak için <code>source</code> veya kısaca <code>.</code> komutunu kullanırız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash
# main.sh

source ./utils.sh
# veya
# . ./utils.sh

log_yaz "Script başladı."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu işlem, <code>utils.sh</code> dosyasının içeriğini sanki o noktaya kopyalayıp yapıştırmışsınız gibi çalıştırır ve içindeki fonksiyonları erişilebilir kılar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_kapsamlı_fonksiyon_örnekleri">9.6. Kapsamlı Fonksiyon Örnekleri</h3>
<div class="paragraph">
<p>Fonksiyonlar konusunu pekiştirmek için, önceki bölümlerde öğrendiğimiz karar yapıları, döngüler ve aritmetik işlemleri de içeren gerçekçi senaryoları inceleyelim.</p>
</div>
<div class="paragraph">
<p><strong>Örnek 1: Log Tutma Fonksiyonu (Renkli ve Tarihli)</strong>
Her script&#8217;te ihtiyaç duyulan, ekrana tarih ve saat ile birlikte renkli hata/bilgi mesajı basan bir fonksiyon.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

# Renk kodları
KIRMIZI='\033[0;31m'
YESIL='\033[0;32m'
NORMAL='\033[0m'

log_yaz() {
    local tur="$1"
    local mesaj="$2"
    local tarih=$(date "+%Y-%m-%d %H:%M:%S")

    case $tur in
        "BILGI")
            echo -e "${YESIL}[$tarih] [BILGI] $mesaj${NORMAL}"
            ;;
        "HATA")
            echo -e "${KIRMIZI}[$tarih] [HATA] $mesaj${NORMAL}"
            ;;
        *)
            echo "[$tarih] $mesaj"
            ;;
    esac
}

# Kullanımı
log_yaz "BILGI" "Script başlatıldı."
log_yaz "HATA" "Dosya bulunamadı!"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Örnek 2: Matematiksel Hesaplama ve Sonuç Döndürme</strong>
Kullanıcıdan alınan sayının karesini hesaplayıp, sonucu değişkene atayalım. Burada <code>echo</code> ile değer döndürme tekniğini kullanacağız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

karesini_al() {
    local sayi=$1
    # Kontrol: Sayısal değilse hata dön (return 1)
    if [[ ! "$sayi" =~ ^[0-9]+$ ]]; then
        return 1
    fi

    # Hesaplamayı yap ve echo ile bas (Bu bizim return değerimiz olacak)
    local kare=$((sayi * sayi))
    echo $kare
}

read -p "Bir sayı girin: " girilen

# Fonksiyonu $(...) içinde çağırıyoruz ki echo çıktısını yakalayalım
sonuc=$(karesini_al "$girilen")

# $? ile fonksiyonun return kodunu (exit status) kontrol edelim
if [ $? -eq 0 ]; then
    echo "Sayının karesi: $sonuc"
else
    echo "Hata: Lütfen geçerli bir sayı giriniz!"
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Örnek 3: Servis Kontrol Fonksiyonu</strong>
Parametre olarak gönderilen bir servisin (örn: nginx, docker) çalışıp çalışmadığını kontrol eden ve duruma göre işlem yapan fonksiyon.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

servis_kontrol() {
    local servis_adi=$1

    # systemctl komutunun çıktısını sessize alıyoruz (&gt; /dev/null)
    # is-active komutu çalışıyorsa 0, çalışmıyorsa farklı kod döner
    if systemctl is-active --quiet "$servis_adi"; then
        return 0
    else
        return 1
    fi
}

hedef_servis="nginx"

# if bloğunda doğrudan fonksiyon çağrılabilir
# Çünkü if, fonksiyonun return değerine (0 mı 1 mi) bakar.
if servis_kontrol "$hedef_servis"; then
    echo "$hedef_servis çalışıyor, her şey yolunda."
else
    echo "UYARI: $hedef_servis çalışmıyor! Başlatılıyor..."
    # sudo systemctl start "$hedef_servis"
fi</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_girdiçıktı_yönlendirme_ve_dosya_i̇şlemleri">10. Girdi/Çıktı Yönlendirme ve Dosya İşlemleri</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_standart_akışlar_stdin_stdout_stderr">10.1. Standart Akışlar (Stdin, Stdout, Stderr)</h3>
<div class="paragraph">
<p>Linux dünyasında "Her şey bir dosyadır" felsefesi hakimdir. Çalıştırdığınız her komut veya program, işletim sistemiyle iletişim kurmak için arka planda <strong>3 tane veri kanalı (akış)</strong> açar. Bu kanalları anlamak, Bash scriptçiliğinin en önemli adımıdır.</p>
</div>
<div class="paragraph">
<p>Bu üç kanalın her birinin bir numarası (File Descriptor - FD) vardır:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Stdin (Standard Input) - [No: 0]:</strong></p>
<div class="ulist">
<ul>
<li>
<p><strong>Giriş Kanalı:</strong> Programın veri aldığı yerdir.</p>
</li>
<li>
<p>Varsayılan olarak <strong>Klavyemizdir</strong>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Stdout (Standard Output) - [No: 1]:</strong></p>
<div class="ulist">
<ul>
<li>
<p><strong>Çıkış Kanalı:</strong> Programın ürettiği başarılı sonuçların gittiği yerdir.</p>
</li>
<li>
<p>Varsayılan olarak <strong>Terminal Ekranıdır</strong>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Stderr (Standard Error) - [No: 2]:</strong></p>
<div class="ulist">
<ul>
<li>
<p><strong>Hata Kanalı:</strong> Programın ürettiği hata mesajlarının gittiği yerdir.</p>
</li>
<li>
<p>Varsayılan olarak bu da <strong>Terminal Ekranıdır</strong>.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Neden Ayrılmışlar?</strong>
Hata mesajları ile gerçek sonuçların birbirine karışmaması için ayrılmışlardır. Örneğin bir yedekleme scriptinin çıktısını dosyaya kaydederken, hataları ekranda görmek isteyebilirsiniz.</p>
</div>
</div>
<div class="sect2">
<h3 id="_yönlendirme_operatörleri_2">10.2. Yönlendirme Operatörleri (<code>&gt;</code>, <code>&gt;&gt;</code>, <code>2&gt;</code>)</h3>
<div class="paragraph">
<p>Standart akışların yönünü değiştirmek için "Yönlendirme Operatörleri"ni kullanırız. Yani çıktıyı ekrana değil dosyaya yazabilir veya girdiyi klavyeden değil dosyadan okuyabiliriz.</p>
</div>
<div class="paragraph">
<p><strong>1. Çıktı Yönlendirme (<code>&gt;</code> ve <code>&gt;&gt;</code>):</strong>
Stdout (1) akışını dosyaya yönlendirir.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&gt;</code> <strong>(Oluştur/Ez):</strong> Dosya yoksa oluşturur, varsa <strong>içini silip</strong> baştan yazar.</p>
</li>
<li>
<p><code>&gt;&gt;</code> <strong>(Ekle - Append):</strong> Dosya yoksa oluşturur, varsa <strong>sonuna ekler</strong>. Eski veriler silinmez.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">echo "Bu satır dosyayı ezer." &gt; dosya.txt
echo "Bu satır sonuna eklenir." &gt;&gt; dosya.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. Hata Yönlendirme (<code>2&gt;</code>):</strong>
Sadece Stderr (2) akışını, yani hata mesajlarını yakalar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Olmayan bir dosyayı listelemeye çalışalım (Hata verir)
ls olmayan_dosya 2&gt; hatalar.log

# Ekranda hiçbir şey görmezsiniz, hata mesajı 'hatalar.log'a yazılır.</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>3. Hepsini Yönlendirme (<code>&amp;&gt;</code> veya <code>2&gt;&amp;1</code>):</strong>
Hem başarılı çıktıları hem de hataları aynı dosyaya göndermek için kullanılır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Modern Bash kullanımı (Önerilen)
komut &amp;&gt; hepsi.log

# Eski yöntem (Stdout dosyaya, Stderr ise Stdout'a)
komut &gt; hepsi.log 2&gt;&amp;1</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>4. Özel Dosya: <code>/dev/null</code></strong>
Linux&#8217;un kara deliğidir. Buraya gönderilen her şey yok olur. Bir komutun çıktısını veya hatasını görmek istemiyorsanız buraya atabilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Çıktıları görmezden gel, sessizce çalış
ping -c 1 google.com &gt; /dev/null 2&gt;&amp;1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pipe_kullanımı_ve_filtreleme">10.3. Pipe (<code>|</code>) Kullanımı ve Filtreleme</h3>
<div class="paragraph">
<p>Linux&#8217;un en güçlü özelliklerinden biri <strong>Pipe (Boru)</strong> sistemidir. Pipe, bir komutun çıktısını (stdout) alıp, doğrudan başka bir komutun girdisine (stdin) bağlar. Bu, zincirleme işlem yapmayı sağlar.</p>
</div>
<div class="paragraph">
<p><strong>Mantık:</strong>
<code>Komut1 | Komut2 | Komut3</code></p>
</div>
<div class="paragraph">
<p><strong>Örnek Senaryo:</strong>
Çalışan süreçler (<code>ps aux</code>) arasında ismi "bash" olanları bulmak (<code>grep</code>), sonra bunları sıralamak (<code>sort</code>) ve sadece ilk 5 tanesini görmek (<code>head</code>) istiyoruz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ps aux | grep "bash" | sort | head -n 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Burada hiçbir ara dosya oluşturulmaz. Veri bir komuttan diğerine "akar".</p>
</div>
<div class="paragraph">
<p><strong>Sık Kullanılan Filtre Komutları:</strong>
Pipe ile birlikte kullanılan bazı temel komutlar şunlardır:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><code>grep</code>:</strong> Metin içinde arama yapar/filtreler.</p>
</li>
<li>
<p><strong><code>sort</code>:</strong> Satırları alfabetik veya sayısal sıralar.</p>
</li>
<li>
<p><strong><code>uniq</code>:</strong> Tekrarlayan satırları eler (Sadece sıralı veride çalışır, bu yüzden önce <code>sort</code> yapılır).</p>
</li>
<li>
<p><strong><code>head</code> / <code>tail</code>:</strong> Dosyanın başını veya sonunu gösterir.</p>
</li>
<li>
<p><strong><code>wc</code>:</strong> Satır, kelime ve karakter sayar (<code>wc -l</code> satır sayar).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Bir klasörde kaç tane .txt dosyası var?
ls *.txt | wc -l</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dosya_varlığı_ve_i̇zin_kontrolleri_tekrar">10.4. Dosya Varlığı ve İzin Kontrolleri (Tekrar)</h3>
<div class="paragraph">
<p>Bölüm 7&#8217;de dosya kontrol operatörlerini (<code>-f</code>, <code>-d</code>) görmüştük. Ancak dosya işlemlerinde güvenlik ve hatasız çalışma için bilinmesi gereken birkaç detay daha vardır.</p>
</div>
<div class="paragraph">
<p><strong>1. Dosya Yazılabilir mi? (<code>-w</code>)</strong>
Bir log dosyasına yazmadan önce, oraya yazma iznimiz olup olmadığını kontrol etmek iyi bir pratiktir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">dosya="/var/log/ozel.log"

if [ -w "$dosya" ]; then
    echo "Log yazılıyor..." &gt;&gt; "$dosya"
else
    echo "Hata: Dosyaya yazma izniniz yok!" &gt;&amp;2
    exit 1
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. Dosya Boş mu? (<code>-s</code>)</strong>
<code>-s</code> (size) operatörü, dosya varsa ve boyutu 0&#8217;dan büyükse TRUE döner. Dosyanın içinin boş olup olmadığını anlamak için kullanılır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">if [ -s "veri.txt" ]; then
    echo "Dosya dolu, işlem başlatılıyor."
else
    echo "Dosya boş veya yok!"
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>3. <code>/dev/null</code> ile Çöp Kutusu</strong>
Bazen bir komutun çıktısıyla hiç ilgilenmeyiz. Sadece hata verip vermediği önemlidir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># grep çıktısı ekrana gelmesin, sadece bulup bulmadığına (exit status) bakalım
if grep -q "Hata" log.txt; then
    echo "Log dosyasında hata bulundu!"
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Not: <code>grep -q</code> (quiet), çıktıyı `/dev/null&#8217;a göndermekle eşdeğerdir ve daha hızlıdır.</strong></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_otomasyon_ve_i̇leri_konular">11. Otomasyon ve İleri Konular</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_cron_ile_zamanlanmış_görevler">11.1. Cron ile Zamanlanmış Görevler</h3>
<div class="paragraph">
<p>Sistem yöneticiliğinin olmazsa olmazı otomasyondur. Bir scripti her gece 03:00&#8217;te çalıştırmak veya her 5 dakikada bir sunucuyu kontrol etmek için <strong>Cron</strong> servisini kullanırız. Cron, arka planda sessizce çalışan ve zamanı gelen işleri tetikleyen bir "zamanlayıcı daemon"dur.</p>
</div>
<div class="paragraph">
<p><strong>Crontab (Cron Table) Nedir?</strong>
Her kullanıcının kendine ait bir görev çizelgesi (tablosu) vardır. Bu tabloyu düzenlemek için terminale şu komutu yazarız:
<code>crontab -e</code></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[!NOTE]
<code>sudo crontab -e</code> komutu root kullanıcısının zamanlayıcısını açar. Normal kullanıcı ile root&#8217;un görevleri ayrı dosyalarda tutulur.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>Zamanlama Sözdizimi (Syntax):</strong>
Cron dosyası 5 yıldızlı bir zamanlayıcı sistemi kullanır:</p>
</div>
<div class="paragraph">
<p><code>* * * * * /komut/yolu</code></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Dakika</strong> (0-59)</p>
</li>
<li>
<p><strong>Saat</strong> (0-23)</p>
</li>
<li>
<p><strong>Ayın Günü</strong> (1-31)</p>
</li>
<li>
<p><strong>Ay</strong> (1-12)</p>
</li>
<li>
<p><strong>Haftanın Günü</strong> (0-6) (0=Pazar, 1=Pazartesi&#8230;&#8203;)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Zamanlama İçin Özel Karakterler:</strong>
*   <code><strong></code> : Her (Her dakika, her saat&#8230;&#8203;)
*   <code>,</code> : Liste (Örn: <code>1,15,30</code> &#8594; 1., 15. ve 30. dakikalarda)
*   <code>-</code> : Aralık (Örn: <code>1-5</code> &#8594; 1&#8217;den 5&#8217;e kadar)
*   <code>/</code> : Periyot/Tekrar (Örn: <code></strong>/10</code> &#8594; Her 10 dakikada bir)</p>
</div>
<div class="paragraph">
<p><strong>Pratik Örnekler:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text"># Her gece saat 03:00'te yedek al
0 3 * * * /home/kullanici/scripts/yedekle.sh

# Hafta içi her gün (Pzt-Cum) sabah 08:30'da rapor gönder
30 8 * * 1-5 /home/kullanici/scripts/raporla.sh

# Her 15 dakikada bir çalış
*/15 * * * * /home/kullanici/scripts/kontrol.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Özel Kısayollar (Special Strings):</strong>
5 yıldızla uğraşmak istemeyenler için pratik takma adlar vardır:
*   <code>@reboot</code> : Sunucu her yeniden başladığında 1 kez çalışır (Çok kullanışlıdır!).
*   <code>@daily</code> veya <code>@midnight</code> : Her gece 00:00&#8217;da çalışır (<code>0 0 * * *</code>).
*   <code>@hourly</code> : Her saat başı çalışır (<code>0 * * * *</code>).</p>
</div>
<div class="paragraph">
<p><strong>Çıktı ve Hata Yönetimi (ÖNEMLİ):</strong>
Cron, çalıştırdığı komutların çıktısını (stdout/stderr) varsayılan olarak kullanıcıya <strong>e-posta</strong> olarak atmaya çalışır. Sunucuda mail kurulumu yoksa bu çıktılar kaybolur veya hata verir.
Bu yüzden çıktıları mutlaka log dosyasına yönlendirin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text"># Çıktıları ve hataları loga yaz
* * * * * /home/user/script.sh &gt;&gt; /var/log/cron_script.log 2&gt;&amp;1

# Çıktıları çöpe at (Sessiz mod)
* * * * * /home/user/script.sh &gt; /dev/null 2&gt;&amp;1</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Altın Kural: PATH Sorunu</strong>
Cron, sizin terminalinizdeki çevre değişkenlerini (<code>PATH</code>) bilmez. Terminalde <code>python main.py</code> yazarsınız çalışır, ama Cron&#8217;da çalışmaz.
Çözüm:
1.  <strong>Tam Yol Kullanın:</strong> <code>python</code> yerine <code>/usr/bin/python3</code>, <code>yedek.sh</code> yerine <code>/home/user/yedek.sh</code>.
2.  <strong>Script İçinde PATH Tanımlayın:</strong> Scriptinizin en başına <code>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</code> ekleyin.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hata_ayıklama_debugging_teknikleri">11.2. Hata Ayıklama (Debugging) Teknikleri</h3>
<div class="paragraph">
<p>Yazdığınız script çalışmıyor veya beklenmedik sonuçlar veriyorsa, hatanın kaynağını bulmak için Bash&#8217;in sunduğu hata ayıklama modlarını kullanabilirsiniz.</p>
</div>
<div class="paragraph">
<p><strong>1. <code>set -x</code> (X-Ray Modu):</strong>
Scriptin çalışırken hangi komutları işlettiğini, değişkenlerin o anki değerlerini ekrana basar. Hatanın nerede olduğunu görmek için mükemmeldir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash
set -x  # Hata ayıklamayı başlat

ad="Ender"
echo "Merhaba $ad"

set +x  # Hata ayıklamayı kapat</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. Scripti Debug Modunda Çalıştırmak:</strong>
Scriptin içine kod yazmadan, çalıştırırken de bu modu açabilirsiniz:
<code>bash -x scriptiniz.sh</code></p>
</div>
<div class="paragraph">
<p><strong>3. <code>set -e</code> (Hata Olursa Dur):</strong>
Normalde Bash, bir satırda hata olsa bile diğer satıra geçip çalışmaya devam eder (bu bazen felakete yol açabilir). <code>set -e</code> komutu, <strong>herhangi bir komut hata verirse (exit code != 0) scripti anında durdurur.</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash
set -e

cd /olmayan/klasor  # Burası hata verecek
rm -rf *            # set -e olduğu için bu tehlikeli komut ASLA çalışmaz!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Güvenli scriptler yazmak için scriptlerinizin başına <code>set -e</code> eklemeyi alışkanlık haline getirin.</p>
</div>
</div>
<div class="sect2">
<h3 id="_temel_regex_düzenli_i̇fadeler_kullanımı">11.3. Temel Regex (Düzenli İfadeler) Kullanımı</h3>
<div class="paragraph">
<p>Regular Expressions (Regex), metinler içinde karmaşık desenleri tanımlamak ve aramak için kullanılan evrensel bir dildir. Bash&#8217;te özellikle <code>grep</code> komutuyla ve <code>[[ &#8230;&#8203; =~ &#8230;&#8203; ]]</code> koşul yapısında kullanılır.</p>
</div>
<div class="paragraph">
<p><strong>Temel Semboller:</strong>
*   <code>^</code> : Satır başı (Örn: <code>^Hata</code> &#8594; Satır "Hata" ile başlıyorsa)
*   <code>$</code> : Satır sonu (Örn: <code>tamam$</code> &#8594; Satır "tamam" ile bitiyorsa)
*   <code>.</code> : Herhangi bir tek karakter
*   <code>*</code> : Kendinden önceki karakterden 0 veya daha fazla tekrar
*   <code>[ ]</code> : Karakter kümesi (Örn: <code>[0-9]</code> rakamlar, <code>[a-z]</code> küçük harfler)</p>
</div>
<div class="paragraph">
<p><strong>Örnekler:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># E-posta formatı kontrolü (Basit)
read -p "Mail adresi: " mail

if [[ "$mail" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
    echo "Format geçerli."
else
    echo "Geçersiz mail formatı!"
fi

# Bir dosyada sadece rakamlardan oluşan satırları bul
grep "^[0-9]*$" veriler.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Regex öğrenmek ayrı bir kitap konusudur, ancak bu temel sembolleri bilmek çoğu işinizi çözecektir.</p>
</div>
</div>
<div class="sect2">
<h3 id="_awk_ve_sed_ile_metin_i̇şlemeye_giriş">11.4. <code>awk</code> ve <code>sed</code> ile Metin İşlemeye Giriş</h3>
<div class="paragraph">
<p>Bash&#8217;in kendi string özellikleri (<code>${var&#8230;&#8203;}</code>) basit işlemler için yeterlidir. Ancak elimizde binlerce satırlık log dosyaları, CSV verileri veya karmaşık metin yığınları varsa, sahneye Linux&#8217;un iki süper kahramanı çıkar: <code>sed</code> ve <code>awk</code>.</p>
</div>
<div class="paragraph">
<p>Bu araçlar aslında kendi başlarına birer programlama dilidir. Bash scriptlerinizde bunları "çağırıp" işleri yaptırrısınız.</p>
</div>
<div class="paragraph">
<p><strong>1. <code>sed</code> (Stream Editor): Metin Cerrahı</strong>
<code>sed</code>, bir metni satır satır okur ve üzerinde silme, değiştirme, ekleme işlemleri yapar. En büyük gücü "Bul ve Değiştir" özelliğidir.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Temel Değiştirme (Substitute):</strong> <code>s/eski/yeni/</code> kalıbı kullanılır.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre># 'elma' kelimesini 'armut' yap (Sadece ekrana basar, orijinal dosyaya dokunmaz)
sed 's/elma/armut/' dosya.txt

# 'g' (global) parametresi ile satırdaki TÜM 'elma'ları değiştirir (yoksa sadece ilkini yapar)
sed 's/elma/armut/g' dosya.txt</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Dosyayı Yerinde Değiştirme (<code>-i</code>):</strong>
Normalde <code>sed</code> sonucu alır ekrana basar. Dosyayı kalıcı değiştirmek için <code>-i</code> (in-place) kullanılır.
&gt; [!WARNING]
&gt; <code>-i</code> kullanırken dikkatli olun! Hata yaparsanız dosyanız bozulur. Güvenlik için <code>-i.bak</code> kullanarak yedeğini alabilirsiniz.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># dosya.txt.bak yedeğini oluşturur, sonra dosya.txt'yi değiştirir
sed -i.bak 's/eski/yeni/g' dosya.txt</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Ayraç Sorunu (Slash <code>/</code> Karakteri):</strong>
Eğer <code>/usr/bin/python</code> gibi slash içeren bir metni değiştirecekseniz, <code>s///</code> yapısı karışır. Bunun yerine başka bir karakter (örn: <code>#</code> veya <code>|</code>) kullanabilirsiniz.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre># /var/www yolunu /home/web ile değiştir
sed 's#/var/www#/home/web#g' config.conf</pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. <code>awk</code>: Sütun ve Veri Analisti</strong>
<code>awk</code> verileri satır (record) ve sütun (field) olarak görür. Özellikle boşlukla veya virgülle ayrılmış verilerde (loglar, CSV) inanılmaz güçlüdür.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Sütun Seçme:</strong> <code>$1</code>, <code>$2</code>&#8230;&#8203; sütunları temsil eder. <code>$0</code> satırın tamamıdır.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre># 'ls -l' çıktısından sadece Dosya Boyutu ($5) ve Dosya Adını ($9) al
ls -l | awk '{print $5, $9}'</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Özel Ayraç Belirleme (<code>-F</code>):</strong>
Varsayılan olarak boşluğa göre böler. Eğer <code>/etc/passwd</code> gibi <code>:</code> ile ayrılmış bir dosya okuyorsanız:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre># Kullanıcı adlarını ($1) yazdır
awk -F':' '{print $1}' /etc/passwd</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Dahili Değişkenler (NR, NF):</strong></p>
</li>
<li>
<p><strong>NR (Number of Records):</strong> Kaçıncı satırdayız?</p>
</li>
<li>
<p><strong>NF (Number of Fields):</strong> O satırda kaç sütun var?</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Sadece 5 sütundan fazla veriye sahip satırları yazdır
awk 'NF &gt; 5 {print $0}' log.txt

# Satır numarası ekleyerek yazdır
awk '{print NR, $0}' liste.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Hangisini Ne Zaman Kullanmalı?</strong>
*   <strong><code>sed</code>:</strong> Basit kelime değişiklikleri, satır silme/ekleme işlemleri için. (Metni <strong>düzenler</strong>)
*   <strong><code>awk</code>:</strong> Sütun bazlı veri çekme, hesaplama yapma (toplama/ortalama), mantıksal süzme işlemleri için. (Veriyi <strong>analiz eder</strong>)</p>
</div>
</div>
<div class="sect2">
<h3 id="_loglama_ve_hata_yönetimi">11.5. Loglama ve Hata Yönetimi</h3>
<div class="paragraph">
<p>Profesyonel bir script, ne yaptığını kaydeder ve hataları düzgün yönetir.</p>
</div>
<div class="paragraph">
<p><strong>Neden Log Tutmalıyız?</strong>
*   Hata olduğunda geriye dönüp neyin yanlış gittiğini anlamak için.
*   Zamanlanmış görevlerin (cron) çalışıp çalışmadığını doğrulamak için.</p>
</div>
<div class="paragraph">
<p><strong>Basit Loglama Fonksiyonu:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">log_dosyasi="/var/log/yedekleme.log"

logla() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" &gt;&gt; "$log_dosyasi"
}

logla "Yedekleme işlemi başladı."

# Bir komut çalıştıralım ve sonucuna göre log yazalım
if cp veriler.txt /yedek/ ; then
    logla "Kopyalama BAŞARILI."
else
    # Hatayı hem loga hem de Stderr'e yazalım
    hata_mesaji="Kopyalama BAŞARISIZ oldu!"
    logla "[HATA] $hata_mesaji"
    echo "$hata_mesaji" &gt;&amp;2
    exit 1
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Hata Yakalama (Trap):</strong>
Script aniden sonlandırılırsa (CTRL+C) veya hata alıp kapanırsa, arkada çöp dosya (<code>/tmp/&#8230;&#8203;</code>) bırakmamak için <code>trap</code> komutu kullanılır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">temizlik_yap() {
    echo "Script kapatılıyor, geçici dosyalar siliniyor..."
    rm -f /tmp/gecici_dosya.txt
}

# EXIT sinyali (her türlü çıkış) gelince 'temizlik_yap' fonksiyonunu çalıştır
trap temizlik_yap EXIT

touch /tmp/gecici_dosya.txt
# İşlemler...
# Script bittiğinde 'temizlik_yap' otomatik çalışacaktır.</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pratik_senaryolar_ve_projeler">12. Pratik Senaryolar ve Projeler</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_proje_1_sistem_bilgisi_raporlama_aracı">12.1. Proje 1: Sistem Bilgisi Raporlama Aracı</h3>
<div class="paragraph">
<p>Bu projede, sunucunun o anki durumunu (CPU, RAM, Disk kullanımı) analiz eden ve bize okunabilir bir rapor sunan bir script yazacağız.</p>
</div>
<div class="paragraph">
<p><strong>Amaç:</strong>
*   Değişkenleri ve komut değiştirmeyi (<code>$()</code>) kullanmak.
*   Aritmetik işlemler yapmak.
*   Renkli çıktı üretmek.</p>
</div>
<div class="paragraph">
<p><strong>Script Kodu (<code>sistem_raporu.sh</code>):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

# --- Ayarlar ve Renkler ---
SIYAH='\033[0;30m'
KIRMIZI='\033[0;31m'
YESIL='\033[0;32m'
SARI='\033[0;33m'
MAVI='\033[0;34m'
NORMAL='\033[0m'

baslik_yaz() {
    echo -e "\n${MAVI}=== $1 ===${NORMAL}"
}

# --- 1. Temel Bilgiler ---
baslik_yaz "SİSTEM BİLGİLERİ"
echo "Hostname    : $(hostname)"
echo "Tarih/Saat  : $(date)"
echo "Uptime      : $(uptime -p)"
echo "Çekirdek    : $(uname -r)"

# --- 2. Disk Kullanımı ---
baslik_yaz "DİSK DURUMU (Kök Dizin)"
disk_kullanim=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')

if [ "$disk_kullanim" -ge 90 ]; then
    renk=$KIRMIZI
elif [ "$disk_kullanim" -ge 70 ]; then
    renk=$SARI
else
    renk=$YESIL
fi

echo -e "Kök Dizin Doluluk: ${renk}%${disk_kullanim}${NORMAL}"

# --- 3. RAM Kullanımı ---
baslik_yaz "RAM KULLANIMI"
# free -m çıktısını parse ediyoruz
toplam_ram=$(free -m | awk '/Mem:/ {print $2}')
kullanilan_ram=$(free -m | awk '/Mem:/ {print $3}')
bos_ram=$(free -m | awk '/Mem:/ {print $4}')

echo "Toplam RAM    : ${toplam_ram} MB"
echo "Kullanılan    : ${kullanilan_ram} MB"
echo "Boş           : ${bos_ram} MB"

# --- 4. Sonuç ---
echo -e "\n${YESIL}Rapor başarıyla tamamlandı.${NORMAL}"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Nasıl Çalıştırılır?</strong>
1.  Dosyayı kaydedin: <code>nano sistem_raporu.sh</code>
2.  İzin verin: <code>chmod +x sistem_raporu.sh</code>
3.  Çalıştırın: <code>./sistem_raporu.sh</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_proje_2_otomatik_dosyadizin_yedekleme_scripti">12.2. Proje 2: Otomatik Dosya/Dizin Yedekleme Scripti</h3>
<div class="paragraph">
<p>Bu projede, belirli bir klasörü sıkıştırıp (<code>tar.gz</code>), ismine tarih ekleyerek yedekleyen ve işlemi loglayan bir otomasyon scripti yazacağız.</p>
</div>
<div class="paragraph">
<p><strong>Amaç:</strong>
*   Argüman kontrolü yapmak (Hangi klasör yedeklenecek?).
*   <code>tar</code> komutu ile sıkıştırma.
*   Loglama fonksiyonu kullanmak.
*   Hata yönetimi (<code>trap</code>).</p>
</div>
<div class="paragraph">
<p><strong>Script Kodu (<code>yedekle.sh</code>):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

# --- Ayarlar ---
YEDEK_DIZINI="/home/ender/yedekler"
LOG_DOSYASI="/var/log/yedekleme.log"
ZAMAN_DAMGASI=$(date "+%Y%m%d_%H%M%S")

# --- Log Fonksiyonu ---
logla() {
    local mesaj="$1"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $mesaj" &gt;&gt; "$LOG_DOSYASI"
    echo "$mesaj" # Ekrana da basalım
}

# --- Hazırlık ---
# Yedeklerin konacağı klasör yoksa oluştur
mkdir -p "$YEDEK_DIZINI"

# Kullanıcı klasör adı girmemişse uyar
if [ -z "$1" ]; then
    echo "Kullanım: $0 &lt;yedeklenecek_klasor_yolu&gt;"
    exit 1
fi

HEDEF_KLASOR="$1"

# Hedef klasör gerçekten var mı?
if [ ! -d "$HEDEF_KLASOR" ]; then
    echo "Hata: '$HEDEF_KLASOR' bir klasör değil veya bulunamadı!"
    exit 1
fi

# Klasör adını temizleyelim (/home/user/data -&gt; data)
klasor_adi=$(basename "$HEDEF_KLASOR")
ARSIV_ADI="${YEDEK_DIZINI}/${klasor_adi}_${ZAMAN_DAMGASI}.tar.gz"

# --- İşlem Başlıyor ---
logla "Yedekleme başladı: $HEDEF_KLASOR"

# tar komutu ile sıkıştır (-c: create, -z: gzip, -f: file)
# 2&gt; /dev/null ile hata mesajlarını gizleyebiliriz ama loglamak daha iyidir.
if tar -czf "$ARSIV_ADI" "$HEDEF_KLASOR" 2&gt;&gt; "$LOG_DOSYASI"; then
    logla "Yedekleme BAŞARILI: $ARSIV_ADI"

    # Dosya boyutunu da yazalım
    boyut=$(du -h "$ARSIV_ADI" | awk '{print $1}')
    logla "Yedek Boyutu: $boyut"
else
    logla "[HATA] Yedekleme sırasında sorun oluştu!"
    exit 1
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cron Entegrasyonu:</strong>
Bu scripti her gece çalıştırmak için:
<code>0 3 * * * /home/ender/scripts/yedekle.sh /var/www/html</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_proje_3_log_dosyası_analiz_aracı">12.3. Proje 3: Log Dosyası Analiz Aracı</h3>
<div class="paragraph">
<p>Bu projede, bir web sunucusunun (Apache/Nginx) erişim loglarını okuyup, en çok ziyaret edilen ip adreslerini ve hata kodlarını (404, 500) listeleyen bir analiz aracı yapacağız.</p>
</div>
<div class="paragraph">
<p><strong>Amaç:</strong>
*   <code>awk</code>, <code>sort</code>, <code>uniq</code> komutlarını etkin kullanmak.
*   Pipe (<code>|</code>) zincirleme işlemlerini pekiştirmek.</p>
</div>
<div class="paragraph">
<p><strong>Örnek Log Verisi (<code>access.log</code>):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>192.168.1.10 - - [30/Dec/2025:10:00:01] "GET /index.html HTTP/1.1" 200 1024
192.168.1.15 - - [30/Dec/2025:10:05:01] "GET /admin.php HTTP/1.1" 404 512
192.168.1.10 - - [30/Dec/2025:10:10:01] "POST /login HTTP/1.1" 500 2048</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Script Kodu (<code>log_analiz.sh</code>):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

LOG_DOSYASI=${1:-access.log}

if [ ! -f "$LOG_DOSYASI" ]; then
    echo "Hata: Log dosyası bulunamadı ($LOG_DOSYASI)"
    exit 1
fi

echo "=== LOG ANALİZ RAPORU: $LOG_DOSYASI ==="

# --- 1. En Çok İstek Yapan IP Adresleri (İlk 5) ---
echo -e "\n[TOP 5 IP Adresleri]"
# awk '{print $1}': 1. sütundaki IP'leri al
# sort: Sırala (uniq için gerekli)
# uniq -c: Tekrarları say (count)
# sort -nr: Sayıya göre ters (büyükten küçüğe) sırala
# head -n 5: İlk 5'i göster
awk '{print $1}' "$LOG_DOSYASI" | sort | uniq -c | sort -nr | head -n 5

# --- 2. HTTP Durum Kodları (200, 404 vs) ---
echo -e "\n[HTTP Durum Kodu Dağılımı]"
# Genellikle HTTP kodu 9. sütundadır
awk '{print $9}' "$LOG_DOSYASI" | sort | uniq -c | sort -nr

# --- 3. 404 Hataları (Sayfa Bulunamadı) ---
echo -e "\n[404 Hataları]"
# HTTP kodu 404 olan satırları bul ve say
hata_sayisi=$(grep " 404 " "$LOG_DOSYASI" | wc -l)
echo "Toplam 404 Hatası: $hata_sayisi"

# --- 4. Potansiyel Saldırganlar (Çok Fazla 404 Alanlar) ---
echo -e "\n[Şüpheli IP'ler (404 Alanlar)]"
grep " 404 " "$LOG_DOSYASI" | awk '{print $1}' | sort | uniq -c | sort -nr | head -3</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_proje_4_kullanıcı_yönetim_otomasyonu">12.4. Proje 4: Kullanıcı Yönetim Otomasyonu</h3>
<div class="paragraph">
<p>Bu projede, <code>kullanicilar.txt</code> adında bir dosyadan "KullanıcıAdı:Departman" formatındaki verileri okuyup, bu kullanıcıları sisteme ekleyen, onlara rastgele bir parola oluşturan ve bunları bir rapora yazan script hazırlayacağız.</p>
</div>
<div class="paragraph">
<p><strong>Amaç:</strong>
*   Dosya okuma döngüsü (<code>while read</code>).
*   String manipülasyonu (Bölme işlemleri).
*   Rastgele veri üretimi (<code>$RANDOM</code> veya <code>openssl</code>).
*   Global komutlar (<code>useradd</code>, <code>chpasswd</code>).</p>
</div>
<div class="paragraph">
<p><strong>Girdi Dosyası (<code>kullanicilar.txt</code>):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>ahmet:IT
ayse:IK
mehmet:Finans</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Script Kodu (<code>kullanici_ekle.sh</code>):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash

DOSYA="kullanicilar.txt"
CIKTI_DOSYASI="yeni_kullanicilar.csv"

# Root kontrolü (Kullanıcı eklemek için root olmak gerekir)
if [ "$EUID" -ne 0 ]; then
    echo "Lütfen bu scripti root yetkisiyle çalıştırın (sudo)."
    exit 1
fi

echo "Kullanıcı Adı,Parola,Departman" &gt; "$CIKTI_DOSYASI"

while read -r satir; do
    # Satır boşsa atla
    [ -z "$satir" ] &amp;&amp; continue

    # Veriyi ':' karakterine göre böl
    # IFS (Internal Field Separator) kullanarak değişkenlere atama
    IFS=':' read -r kullanici departman &lt;&lt;&lt; "$satir"

    # Kullanıcı zaten var mı?
    if id "$kullanici" &amp;&gt;/dev/null; then
        echo "$kullanici zaten mevcut, atlanıyor."
        continue
    fi

    echo "Ekleniyor: $kullanici ($departman)"

    # 1. Kullanıcıyı oluştur (-m: home dizini oluştur, -s: shell belirle)
    useradd -m -s /bin/bash "$kullanici"

    # 2. Rastgele parola oluştur (openssl ile)
    parola=$(openssl rand -base64 12)

    # 3. Parolayı ayarla
    echo "$kullanici:$parola" | chpasswd

    # 4. Bilgileri CSV dosyasına kaydet
    echo "$kullanici,$parola,$departman" &gt;&gt; "$CIKTI_DOSYASI"

done &lt; "$DOSYA"

echo -e "\nİşlem tamamlandı! Şifreler '$CIKTI_DOSYASI' dosyasında."</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Güvenlik Uyarısı:</strong>
Scriptin ürettiği <code>yeni_kullanicilar.csv</code> dosyasında parolalar açık metin olarak yazar. İşiniz bitince bu dosyayı güvenli bir şekilde silmeyi veya şifrelemeyi unutmayın!</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ek_a_terminal_kısayolları">Appendix A: Ek A: Terminal Kısayolları</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bash terminalini bir usta gibi kullanmak için farenizi bırakın ve bu kısayolları ezberleyin. Hızınızı 10 kat artıracaktır.</p>
</div>
<div class="sect2">
<h3 id="_i̇mleç_hareketi">A.1. İmleç Hareketi</h3>
<div class="ulist">
<ul>
<li>
<p><strong>CTRL + A</strong> : Satır başını gider.</p>
</li>
<li>
<p><strong>CTRL + E</strong> : Satır sonuna gider.</p>
</li>
<li>
<p><strong>ALT + B</strong>  : Bir kelime geri gider (Back).</p>
</li>
<li>
<p><strong>ALT + F</strong>  : Bir kelime ileri gider (Forward).</p>
</li>
<li>
<p><strong>CTRL + XX</strong> : İmleç ile satır başı arasında gidip gelir.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_düzenleme_ve_silme">A.2. Düzenleme ve Silme</h3>
<div class="ulist">
<ul>
<li>
<p><strong>CTRL + U</strong> : İmleçten satır başına kadar her şeyi siler (Hatalı yazdığınızda hayat kurtarır).</p>
</li>
<li>
<p><strong>CTRL + K</strong> : İmleçten satır sonuna kadar her şeyi siler.</p>
</li>
<li>
<p><strong>CTRL + W</strong> : İmleçten geriye doğru bir kelime siler.</p>
</li>
<li>
<p><strong>CTRL + L</strong> : Ekranı temizler (<code>clear</code> komutuyla aynıdır).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_geçmiş_ve_arama">A.3. Geçmiş ve Arama</h3>
<div class="ulist">
<ul>
<li>
<p><strong>CTRL + R</strong> : Geçmişte komut arar (Reverse Search). Yazmaya başladığınızda eşleşen en son komutu bulur. Tekrar basarsanız daha eskiye gider.</p>
</li>
<li>
<p><strong>Up / Down Okları</strong>: Geçmişteki komutları sırayla getirir.</p>
</li>
<li>
<p><strong>!!</strong> : Son çalıştırılan komutu tekrar eder (Örn: <code>sudo !!</code>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_süreç_kontrolü">A.4. Süreç Kontrolü</h3>
<div class="ulist">
<ul>
<li>
<p><strong>CTRL + C</strong> : Çalışan komutu iptal eder/öldürür (SIGINT).</p>
</li>
<li>
<p><strong>CTRL + Z</strong> : Çalışan komutu durdurur ve arka plana atar (SIGSTOP). (<code>fg</code> ile geri alabilirsiniz).</p>
</li>
<li>
<p><strong>CTRL + D</strong> : Terminalden çıkış yapar (<code>exit</code> komutuyla aynıdır).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ek_b_genişletilmiş_linux_komutları_referansı">Appendix B: Ek B: Genişletilmiş Linux Komutları Referansı</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bash script yazarken veya sunucu yönetirken elinizin altında bulunması gereken <strong>temel ve ileri seviye</strong> komutların kapsamlı listesi.</p>
</div>
<div class="sect2">
<h3 id="_1_dosya_ve_dizin_yönetimi">B.1. 1. Dosya ve Dizin Yönetimi</h3>
<div class="paragraph">
<p>Dosya sisteminde gezinmek ve düzenleme yapmak için gerekenler.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ls -lah</code> : Tüm dosyları (gizliler dahil), boyutları ve izinleriyle listeler.</p>
</li>
<li>
<p><code>cd -</code> : Bir önceki bulunduğunuz klasöre geri döner (Geri tuşu gibi).</p>
</li>
<li>
<p><code>mkdir -p a/b/c</code> : İç içe klasör ağacı oluşturur.</p>
</li>
<li>
<p><code>cp -r kaynak hedef</code> : Klasörleri içeriğiyle birlikte kopyalar.</p>
</li>
<li>
<p><code>mv dosya yeni_ad</code> : Dosya taşır veya yeniden adlandırır.</p>
</li>
<li>
<p><code>rm -rf klasor</code> : Klasörü ve içindekileri <strong>sorgusuz sualsiz</strong> siler.</p>
</li>
<li>
<p><code>ln -s dosya link</code> : Dosyaya sembolik link (kısayol) oluşturur.</p>
</li>
<li>
<p><code>file dosya</code> : Dosyanın türünü (resim, metin, script vb.) söyler.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_2_dosya_arama_ve_bulma">B.2. 2. Dosya Arama ve Bulma</h3>
<div class="ulist">
<ul>
<li>
<p><code>find / -name "log*"</code> : Tüm sistemde ismi log ile başlayan dosyaları arar.</p>
</li>
<li>
<p><code>find . -type f -size +100M</code> : 100MB&#8217;dan büyük dosyaları bulur.</p>
</li>
<li>
<p><code>grep -r "hata" .</code> : Bulunduğunuz klasördeki tüm dosyaların İÇİNDE "hata" kelimesini arar.</p>
</li>
<li>
<p><code>locate dosya</code> : Dosyayı veritabanından ışık hızında bulur (önce <code>updatedb</code> yapmak gerekir).</p>
</li>
<li>
<p><code>which komut</code> : Bir komutun hangi klasörde çalıştığını gösterir (Örn: <code>which python</code>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_3_arşivleme_ve_sıkıştırma">B.3. 3. Arşivleme ve Sıkıştırma</h3>
<div class="ulist">
<ul>
<li>
<p><code>tar -czf arsiv.tar.gz klasor</code> : Klasörü <code>.tar.gz</code> olarak sıkıştırır.</p>
</li>
<li>
<p><code>tar -xzf arsiv.tar.gz</code> : <code>.tar.gz</code> dosyasını olduğu yere çıkarır.</p>
</li>
<li>
<p><code>zip -r dosya.zip klasor</code> : Klasörü zip formatında sıkıştırır.</p>
</li>
<li>
<p><code>unzip dosya.zip</code> : Zip dosyasını açar.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_4_sistem_i̇zleme_ve_performans">B.4. 4. Sistem İzleme ve Performans</h3>
<div class="ulist">
<ul>
<li>
<p><code>top</code> / <code>htop</code> : İşlemci ve RAM kullanımını canlı gösterir. (<code>htop</code> daha renklidir).</p>
</li>
<li>
<p><code>df -h</code> : Disk doluluk oranlarını (GB/TB cinsinden) gösterir.</p>
</li>
<li>
<p><code>du -sh *</code> : Bulunduğunuz klasördeki her bir dosyanın/klasörün boyutunu gösterir.</p>
</li>
<li>
<p><code>free -m</code> : RAM durumunu MB cinsinden gösterir.</p>
</li>
<li>
<p><code>uptime</code> : Sistemin ne kadar süredir açık olduğunu gösterir.</p>
</li>
<li>
<p><code>dmesg</code> : Çekirdek (kernel) ve donanım mesajlarını görüntüler.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_5_ağ_ve_bağlantı_networking">B.5. 5. Ağ ve Bağlantı (Networking)</h3>
<div class="ulist">
<ul>
<li>
<p><code>ip addr</code> : IP adresini gösterir.</p>
</li>
<li>
<p><code>ping -c 4 google.com</code> : Bağlantıyı test eder (4 paket atıp durur).</p>
</li>
<li>
<p><code>curl -I <a href="https://site.com" class="bare">https://site.com</a></code> : Sitenin HTTP başlık bilgilerini çeker.</p>
</li>
<li>
<p><code>wget &lt;url&gt;</code> : Dosya indirir.</p>
</li>
<li>
<p><code>netstat -tulpn</code> : Hangi portun hangi program tarafından dinlendiğini gösterir.</p>
</li>
<li>
<p><code>ss -tuln</code> : `netstat&#8217;ın modern halidir, açık portları gösterir.</p>
</li>
<li>
<p><code>dig site.com</code> : DNS sorgusu yapar.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_6_uzak_bağlantı_ve_transfer">B.6. 6. Uzak Bağlantı ve Transfer</h3>
<div class="ulist">
<ul>
<li>
<p><code>ssh user@ip</code> : Uzak sunucuya bağlanır.</p>
</li>
<li>
<p><code>scp dosya user@ip:/hedef</code> : Dosyayı güvenli şekilde karşı sunucuya kopyalar.</p>
</li>
<li>
<p><code>rsync -avz kaynak hedef</code> : Dosyaları akıllıca senkronize eder (Sadece değişenleri atar).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_7_kullanıcı_ve_i̇zinler">B.7. 7. Kullanıcı ve İzinler</h3>
<div class="ulist">
<ul>
<li>
<p><code>sudo command</code> : Komutu yönetici (root) yetkisiyle çalıştırır.</p>
</li>
<li>
<p><code>chmod 755 dosya</code> : Çalıştırma izni verir.</p>
</li>
<li>
<p><code>chown user:group dosya</code> : Dosyanın sahibini değiştirir.</p>
</li>
<li>
<p><code>useradd -m yeniuser</code> : Yeni kullanıcı oluşturur.</p>
</li>
<li>
<p><code>passwd user</code> : Kullanıcının şifresini değiştirir.</p>
</li>
<li>
<p><code>whoami</code> : Hangi kullanıcı ile bağlı olduğunuzu söyler.</p>
</li>
<li>
<p><code>last</code> : Sisteme en son kimlerin girdiğini listeler.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_8_süreç_process_yönetimi">B.8. 8. Süreç (Process) Yönetimi</h3>
<div class="ulist">
<ul>
<li>
<p><code>ps aux | grep java</code> : Çalışan Java uygulamalarını bulur.</p>
</li>
<li>
<p><code>kill &lt;PID&gt;</code> : PID numarası verilen uygulamayı nazikçe kapatır.</p>
</li>
<li>
<p><code>kill -9 &lt;PID&gt;</code> : Uygulamayı zorla öldürür (Force Kill).</p>
</li>
<li>
<p><code>killall firefox</code> : İsminden tüm Firefox süreçlerini kapatır.</p>
</li>
<li>
<p><code>bg</code> / <code>fg</code> : Arka plandaki işi öne alır veya tam tersi.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2025-12-31 00:40:28 +0300
</div>
</div>
</body>
</html>